<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>ECMAScript5.1-(10)可执行代码和执行上下文 | Calvin&#39;s notes</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="10.1 可执行代码的类型在ES规范中有三种可执行代码：  Global code 即ES Program的源文本。一个Program的代码不包含任何可被解析为FunctionBody的文本。 Eval code 内置函数eval被调用时传入的文本。 Function code 被解析为FunctionBody的源文本。FunctionBody中的function code不包含任何内层的可被解析">
<meta property="og:type" content="article">
<meta property="og:title" content="ECMAScript5.1-(10)可执行代码和执行上下文">
<meta property="og:url" content="http://www.qiwenke.com/2017/07/02/ECMAScript5-1-10-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/index.html">
<meta property="og:site_name" content="Calvin&#39;s notes">
<meta property="og:description" content="10.1 可执行代码的类型在ES规范中有三种可执行代码：  Global code 即ES Program的源文本。一个Program的代码不包含任何可被解析为FunctionBody的文本。 Eval code 内置函数eval被调用时传入的文本。 Function code 被解析为FunctionBody的源文本。FunctionBody中的function code不包含任何内层的可被解析">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2017-07-02T20:00:00.000Z">
<meta property="article:modified_time" content="2020-03-22T15:32:36.535Z">
<meta property="article:author" content="Calvin">
<meta property="article:tag" content="Javascript">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Calvin&#39;s notes" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  

  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/css/prism.css">

    
<link rel="stylesheet" href="/css/prism_custom.css">

  
<meta name="generator" content="Hexo 4.2.0"></head>

<body><div class="site-column-post">
  <div class="site-content-post">
      <article class="post-all-content">
          <div class="post-name">
            <h2>ECMAScript5.1-(10)可执行代码和执行上下文</h2>
          </div>
          <div class="post-info">
              <span class="post-info-date">
                <i class="iconfont icon-calendar"></i>
                2017-07-02
              </span>
              <span class="post-update">
                <i class="iconfont icon-copy"></i>
                2020-03-22
              </span>
              
              <span class="post-category">
                <i class="iconfont icon-folder"></i>
                
                  
                    <a href="/categories/技术/">技术</a>
                  
                
                  
                
                  
                
              </span>
              
              
              <span class="post-tag">
                <i class="iconfont icon-collection"></i>
                
                  <a href="/tags/Javascript/">Javascript</a>
                
              </span>
              
              <span class="back-to-home">
                <a href="/">
                  <span>Calvin&#39;s notes</span>
                  <i class="iconfont icon-home"></i>
                </a>
              </span>
          </div>
          <div class="post-body">
            <h2 id="10-1-可执行代码的类型"><a href="#10-1-可执行代码的类型" class="headerlink" title="10.1 可执行代码的类型"></a>10.1 可执行代码的类型</h2><p>在ES规范中有三种可执行代码：</p>
<ul>
<li><em>Global code</em> 即ES Program的源文本。一个Program的代码不包含任何可被解析为FunctionBody的文本。</li>
<li><em>Eval code</em> 内置函数eval被调用时传入的文本。</li>
<li><em>Function code</em> 被解析为FunctionBody的源文本。FunctionBody中的function code不包含任何内层的可被解析为FunctionBody的源文本。当内置的Function方法作为构造函数被调用时，最后一个参数会被转化为字符串后也被当作FunctioBody.</li>
</ul>
<h2 id="10-2-Lexical-Environment"><a href="#10-2-Lexical-Environment" class="headerlink" title="10.2 Lexical Environment"></a>10.2 Lexical Environment</h2><p>Lecical Environment(简称LE)是一种规范类型，该类型以代码的词法嵌套结构为基础，定义了指定变量、函数与标志符的关联关系。一个LE由Environment Record(简称ER)和一个可能为空的outer LE组成。通常一个LE是和指定的code相关联的，比如FunctionDelcaration，WithStatement，TryStatement的Catch从句，这些代码每执行一次就会生成一个新的Lecical Environment。</p>
<p>一个Environent Record记录了相关联的LE作用域内的identifier bindings。</p>
<p>内层LE的outer LE，是对在词发上包裹内层LE的LE的引用。一个outer LE也会有自己的outer LE。一个LE可以作为多个内层LE的outer LE。比如，一个在一个FunctionDeclaration内包含了两个FunctionDeclarations，那么这两个函数声明的outer LE会共享一个LE，即外层的LE。</p>
<p>LE和ER是ES规范的内部实现类型，仅供规范使用无法通过任何代码进行使用。</p>
<h3 id="10-2-1-Environment-Records"><a href="#10-2-1-Environment-Records" class="headerlink" title="10.2.1 Environment Records"></a>10.2.1 Environment Records</h3><p>此规范中有两种ER，declarative enbironment records(简称DER)和objcet environment records(简称OER)。DER作用于ES规范中的语法元素有FunctionDeclaration，VariableDeclarations，Catch从句，它将identifiers bindings和ES类型值相关联。OER则作用于ES Program和WithStatement，它将iderntifiers binding和某个对象的属性相关联。</p>
<p>在规范中，可以用面向对象的方式理解ER。ER是一个抽象类，它作为父类被DER和OER继承。ER作为抽象类，包含了Table 17中的抽象操作方法，而每个子类负责对这些方法进行具体实现。</p>
<p>Table 17-ER的抽象方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>HasBinding(N)</td>
<td>判断一个ER是否有针对某个标志符的binding，如果有责则返回true，否则返回false。N是标志符的字符串名称。</td>
</tr>
<tr>
<td>CreateMutableBinding(N,D)</td>
<td>在ER中创建一个可变binding。N是bound name。如果可选布尔参数D为true，那么创建的binding可以被随后的操作删除。</td>
</tr>
<tr>
<td>SetMutableBinding(N,V,S)</td>
<td>对ER中已经存在的binding进行设置。N是bound name，V是将要设置给binding的值，该值可以是ES语言的任何类型的值。S是一个布尔标识，如果S为true，那么binding无法被设置且抛出异常TyperError。</td>
</tr>
<tr>
<td>GetBindingValue(N,S)</td>
<td>返回ER中已存在的binding的值。N是bound name。S用于标识是否为严格模式，如果S为true且当前binding不存在或未被初始化，则抛出异常ReferenceError。</td>
</tr>
<tr>
<td>Deletebinding(N)</td>
<td>在ER中删除binding。N是bound name，如果N的binding存在则删除该binding并返回true。如果binding存在但不能被删除则返回false。如果binding不存在返回true。</td>
</tr>
<tr>
<td>ImplicitThisValue()</td>
<td>返回一个值，当ER中的某个binding值为函数且被调用时，该值作为函数的this值。</td>
</tr>
</tbody></table>
<h4 id="10-2-1-1-Declarative-Environment-Records"><a href="#10-2-1-1-Declarative-Environment-Records" class="headerlink" title="10.2.1.1 Declarative Environment Records"></a>10.2.1.1 Declarative Environment Records</h4><p>每个DER都与包含变量和/或函数声明的ES代码作用域相关。一个DER包装了它作用域内的标识符。</p>
<p>除了可变bindings，DER还提供了不可变bindings。对于不可变bindings，一旦标识符和值之间的关联一旦建立就不能再被更改。不可变bindings的创建和初始化是两个独立的步骤，因此对于不可变bindings，有可能处于初始化，也可能处于未初始化的状态。DER额外提供的方法在Table18中已列出。</p>
<p>Table 18-Declarative Environment Records的新增方法</p>
<table>
<thead>
<tr>
<th>方法</th>
<th>作用</th>
</tr>
</thead>
<tbody><tr>
<td>CreateImmutableBinding(N)</td>
<td>在ER中创建一个新的但是未初始化的不可变binding。N是bound name。</td>
</tr>
<tr>
<td>InitializeImmutableBinding(N,V)</td>
<td>对ER中已存在但没有初始化的binding进行设置。N是bound name。V是要设置的值，可以是ES语言的任何类型值</td>
</tr>
</tbody></table>
<h4 id="10-2-1-2-Object-Environment-Records"><a href="#10-2-1-2-Object-Environment-Records" class="headerlink" title="10.2.1.2 Object Environment Records"></a>10.2.1.2 Object Environment Records</h4><p>每个OER都与一个对象相关联，该对象称之为OER的binding object。一个OER包装的标识符，标识符名称与其binding object的属性名相对应。如果binding object的属性名是非标准标识符名，那么该属性会被OER所忽略。不管binding object包括其原型上的属性是否可枚举，都会被包装进OER之中。由于对象的属性可以动态的增加或删除，所以OER中的bindings也会对应的改变，任何受此动态影像产生的binding都被当作是可变binding，即使binding值的[[Writable]]属性为false。OER中不存在不可变binding。</p>
<h3 id="10-2-2-Lexical-Environment-Operations"><a href="#10-2-2-Lexical-Environment-Operations" class="headerlink" title="10.2.2 Lexical Environment Operations"></a>10.2.2 Lexical Environment Operations</h3><h4 id="10-2-2-1-GetIdentifierReference-lex-name-strict"><a href="#10-2-2-1-GetIdentifierReference-lex-name-strict" class="headerlink" title="10.2.2.1 GetIdentifierReference (lex, name, strict)"></a>10.2.2.1 GetIdentifierReference (lex, name, strict)</h4><p>抽象操作GetIdentifierReference被调用时会传入：一个LE lex，一个标识符字符串name，一个布尔标识strict。lex的值可能为null。执行步骤如下：</p>
<ol>
<li>如果lex的值为null，那么<ul>
<li>a. 返回一个Reference类型的值，该值的base value是undefined，referenced name是name，strict mode标识为strict。</li>
</ul>
</li>
<li>设envRec为lex’s ER。</li>
<li>调用envRec的HasBinding(N)方法，传入name作为参数。返回结果设为exists。</li>
<li>如果exists为true，那么<ul>
<li>a. 返回一个Reference类型的值，该值的base value是envRec，referenced name是name，strict mode标识为strict。</li>
</ul>
</li>
<li>否则<ul>
<li>a. 设outer为lex’s outer ER。</li>
<li>b. 返回GetIdentifierReference(outer,name,strict)的返回结果。</li>
</ul>
</li>
</ol>
<h4 id="10-2-2-2-NewDeclarativeEnvironment-E"><a href="#10-2-2-2-NewDeclarativeEnvironment-E" class="headerlink" title="10.2.2.2 NewDeclarativeEnvironment(E)"></a>10.2.2.2 NewDeclarativeEnvironment(E)</h4><p>当抽象操作NewDeclarativeEnvironment(E)被调用时会传入：一个ER(可能为null) E。执行步骤如下：</p>
<ol>
<li>创建一个新的LE，设置为enc。</li>
<li>设置envRec为一个新的不含任何binding的DER。</li>
<li>将env的ER指向envRec。</li>
<li>将env的outer ER指向E。</li>
<li>返回env。</li>
</ol>
<h4 id="10-2-2-3-NewObjectEnvironment-O-E"><a href="#10-2-2-3-NewObjectEnvironment-O-E" class="headerlink" title="10.2.2.3 NewObjectEnvironment(O, E)"></a>10.2.2.3 NewObjectEnvironment(O, E)</h4><p>当抽象操作NewObjectEnvironment被调用时会传入：一个对象O，一个ER(可能为null)E。执行步骤如下：</p>
<ol>
<li>设env为一个新创建的LE。</li>
<li>设envRec为一个新的OER，该OER包含一个binding object O。</li>
<li>将env的ER指向envRec。</li>
<li>将env的outer ER指向E。</li>
<li>返回env。</li>
</ol>
<h3 id="10-2-3-The-Global-Environment"><a href="#10-2-3-The-Global-Environment" class="headerlink" title="10.2.3 The Global Environment"></a>10.2.3 The Global Environment</h3><p>global environment(简称ge)是唯一一个在ES代码执行前就已经被创建的LE。ge的ER是一个将全局对象作为binding object的OER。ge的outer ER是null。</p>
<p>在ES代码的执行过程中，全局对象有可能会增加新属性，原属性也有可能会被修改。</p>
<h2 id="10-3-Execution-Contexts"><a href="#10-3-Execution-Contexts" class="headerlink" title="10.3 Execution Contexts"></a>10.3 Execution Contexts</h2><p>当代码的执行流进入某个可执行代码后，控制流就进入了某个execution context(执行上下文,简称EC)。活动的EC会组成一个执行栈。执行栈最顶层的EC就是当前正在执行的EC。当执行流从与当前EC相关联的可执行代码进入到另一个与当前EC无关的可执行代码后，就会产生一个新的EC。新的EC则会被压入执行栈成为当前正在执行的EC。</p>
<p>EC中包含了一系列的状态组件，这些组件用于追踪与其相关联的代码的执行情况。每个EC都会包含的三个状态组件，如下表Table 19所示。</p>
<p>Table 19 —Execution Context State Components</p>
<table>
<thead>
<tr>
<th>组件名</th>
<th>用途</th>
</tr>
</thead>
<tbody><tr>
<td>LexicalEnvironment</td>
<td>指向用于对EC执行代码的识符引用进行解析的LE</td>
</tr>
<tr>
<td>VariableEnvironment</td>
<td>指向一个ER中的bindings完全由EC执行代码中的VariableStatements和FunctionDeclarations所产生的LE。</td>
</tr>
<tr>
<td>ThisBinding</td>
<td>在EC中的代码中this关键字的值</td>
</tr>
</tbody></table>
<p>EC中的LexicalEnvironment(词法环境,简称LexEnv)和VariableEnvironment(变量环境,简称VarEnv)都是LE。当EC被创建后，LexEnv和VarEnv被初始化为同一个值。随着EC中代码的执行，VarEnv始终保持不变，而LexEnv则有可能因为代码的执行而发生改变。EC是属于ES规范的范畴，无法通过代码进行访问。</p>
<h3 id="10-3-1-标识符解析-Identifier-Resolution"><a href="#10-3-1-标识符解析-Identifier-Resolution" class="headerlink" title="10.3.1 标识符解析(Identifier Resolution)"></a>10.3.1 标识符解析(Identifier Resolution)</h3><p>标识符解析是指用EC中的LexEnv确定与标识符相关的binding的过程。在ES代码的执行中，表达式：Identifier会按照以下步骤执行：</p>
<ol>
<li>设env为当前EC的LexEnv。</li>
<li>如果当前代码是在严格模式下执行，那么设strict为true，否则设为false。</li>
<li>返回GetIdentifierReference(env,Identifier,strict)的执行返回结果。</li>
</ol>
<h2 id="10-4-创建执行上下文"><a href="#10-4-创建执行上下文" class="headerlink" title="10.4 创建执行上下文"></a>10.4 创建执行上下文</h2><p>全局代码的执行和eval函数中传入的代码的执行都会创建并进入一个新的EC。每个函数代码的调用也会创建并进入一个新的EC，即使在函数递归调用自身的时候。每次return都会退出一个EC，抛出异常时会退出一个/多个EC。</p>
<p>当控制流进入一个EC，EC中的ThisBinding会被设置，VarEnv和初始LexEnv也会被定义，随后declaration binding instantiation(10.5)开始执行。具体的实现步骤取决于当前EC的执行代码类型。</p>
<h3 id="10-4-1-进入全局代码"><a href="#10-4-1-进入全局代码" class="headerlink" title="10.4.1 进入全局代码"></a>10.4.1 进入全局代码</h3><p>当控制流进入全局代码的执行上下文时：</p>
<ol>
<li>按10.4.1.1初始化EC</li>
<li>使用全局代码执行10.5中的 Declaration Binding Instantiation。</li>
</ol>
<h4 id="10-4-1-1"><a href="#10-4-1-1" class="headerlink" title="10.4.1.1"></a>10.4.1.1</h4><p>一个全局代码的EC会按照以下步骤进行初始化：</p>
<ol>
<li>设置VarEnv为全局环境Global Environment。</li>
<li>设置LexEnv为全局环境Global Environment。</li>
<li>设置ThisBinding为全局对象global object。</li>
</ol>
<h3 id="10-4-2-进入Eval代码"><a href="#10-4-2-进入Eval代码" class="headerlink" title="10.4.2 进入Eval代码"></a>10.4.2 进入Eval代码</h3><h3 id="10-4-3-进入函数代码-Entering-Function-Code"><a href="#10-4-3-进入函数代码-Entering-Function-Code" class="headerlink" title="10.4.3 进入函数代码(Entering Function Code)"></a>10.4.3 进入函数代码(Entering Function Code)</h3><p>当执行流进入由函数对象F所包含的代码的EC时，同时有两个值会在调用时被提供，thisArg和argumentsList：</p>
<ol>
<li>如果函数代码处于严格模式，设置ThisBinding为thisArg。</li>
<li>如果thisArg是null或者undefined，设置ThisBinding为全局对象global object。</li>
<li>如果thisArg的类型不是对象，则设置ThisBinding为ToObject(thisArg)。</li>
<li>设置ThisBinding为thisArg。</li>
<li>设localEnv为调用NewDeclarativeEnvironment(F.[[Scope]])的返回值。</li>
<li>设置LexEnv为localEnv。</li>
<li>设置VarEnv为localEnv。</li>
<li>设code为F的内置属性[[Code]]的值。</li>
<li>用code和argumentsList执行10.5中的Declaration Binding Instantiation。</li>
</ol>
<h2 id="10-5-Declaration-Binding-Instantiation"><a href="#10-5-Declaration-Binding-Instantiation" class="headerlink" title="10.5 Declaration Binding Instantiation"></a>10.5 Declaration Binding Instantiation</h2><p>每个EC都有一个VarEnv。在EC内执行的ES代码中声明的变量和函数都会作为bindings被添加到VarEnv的ER中。对于函数来讲，参数也会作为bindings被添加到ER中。</p>
<p>在哪个ER中添加bindings取决于在EC中执行的代码的类型，其余的操作都是通用的。当进入执行上文EC时，bindings会基于被提供的code，如果是函数还会有一个args，按照以下步骤在VarEnv中进行创建：</p>
<ol>
<li>设env为当前正在运行的EC的VarEnv的ER。</li>
<li>如果code是eval代码，那么设configurableBindings为true，否则设为false。</li>
<li>如果code处于严格模式，那么设strict为true，否则设为false。</li>
<li>如果code是函数代码，那么<ul>
<li>a. 设func为通过内部方法[[Call]]发起code执行的那个函数。设names为func’s[[FormalParameters]]的值。</li>
<li>b. 以argName遍历names，如果argName在args中有对应的实参值，则设v为该值，否则设为undefined。调用env的HasBinding操作，传入argName，设返回结果为argAlreadyDeclared。</li>
<li>c. 如果argAlreadyDeclared为false，调用env的CreateMutableBinding方法传入argName作为参数。然后调用env的SetMutableBinding方法传入argName，v，strict作为参数。</li>
</ul>
</li>
<li>对于code中的每一个FunctionDeclaration：<ul>
<li>a. 设fn为FunctionDeclaration中的Identifier。</li>
<li>b. 设fo为FunctionDeclaration按照ES规范13节中初始化得到的函数对象。</li>
<li>c. 设funcAlreadyDeclared为env’s HasBinding(fn)的执行结果。</li>
<li>d. 如果funcAlreadyDeclared为false，调用env’s CreateMutableBinding(fn,configurableBindings)。</li>
<li>e. 否则，如果env是global environment’s ER那么：<ul>
<li>i. 设go为全局对象</li>
<li>ii. 设existingProp为调用go的内置方法[[GetProperty]]并传入fn为参数的执行结果。</li>
<li>iii. 如果existingProp.[[Condigurable]]为true，那么调用go的内置方法[[DefineOwnProperty]]，传入fn，Property Descriptor{[[Value]]:undefined,[[Writable]]:true,[[Enumerable]]:true,[[Configurable]]:configurableBindings}，还有true作为参数。</li>
<li>iv. 否则，如果IsAccessorDescriptor(existingProp)或existingProp不符合{[[Writable]]:true,[[Enumerable]]:true}，那么抛出异常。</li>
</ul>
</li>
<li>f. 调用env’s SetMutableBinding(fn,fo,strict)。</li>
</ul>
</li>
<li>设argumentsAlreadyDeclared为env’s HasBinding(“arguments”)的执行结果。</li>
<li>如果code是函数代码，且argumentsAlreadyDeclared为false，那么<ul>
<li>a. 设argsObj为CreateArgumentsObject(func,names,args,env,strict)的返回结果，即参数对象。</li>
<li>b. 如果strict为true，那么<ul>
<li>i. 调用env’s CreateImmutableBinding(“arguments”)。</li>
<li>ii. 调用env’s InitializeImmutableBinding(“arguments”,argsObj)。</li>
</ul>
</li>
<li>c. 否则<ul>
<li>i. 调用env’s CreateMutableBinding(“arguments”)。</li>
<li>ii. 调用env’s SetMutableBinding(“arguments”,argsObj,false)。</li>
</ul>
</li>
</ul>
</li>
<li>对于每个VariableDeclaration<ul>
<li>a. 设dn为变量的标识符</li>
<li>b. 设varAlreadyDeclared为env’s HasBinding(dn)的执行结果。</li>
<li>c. 如果为false，那么<ul>
<li>i. 调用env’s CreateMutableBinding(dn,configurableBindings)。</li>
<li>ii. 调用env’s SetMutableBinding(dn,undefined,strict)。</li>
</ul>
</li>
</ul>
</li>
</ol>

          </div>
      </article>

      <div class="post-navigation">
        
        <div class="post-previous">
          <a href="/2017/08/16/ECMAScript5-1-11-%E8%A1%A8%E8%BE%BE%E5%BC%8F/">
              <i class="iconfont icon-round-arrow-left"></i> 
              <span class="post-prev-title">ECMAScript5.1-(11)表达式</span>
          </a>
        </div>
        
        
        <div class="post-next">
            <a href="/2017/06/25/ECMAScript5-1-9-%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2/">
                <span class="post-next-title">ECMAScript5.1-(9)类型转换</span>
                <i class="iconfont icon-round-arrow-right"></i>
            </a>
        </div>
        
      </div>
  </div>

  <div id="disqus_thread"></div>
  <script>
  
  /**
  *  RECOMMENDED CONFIGURATION VARIABLES: EDIT AND UNCOMMENT THE SECTION BELOW TO INSERT DYNAMIC VALUES FROM YOUR PLATFORM OR CMS.
  *  LEARN WHY DEFINING THESE VARIABLES IS IMPORTANT: https://disqus.com/admin/universalcode/#configuration-variables*/
  var disqus_config = function () {
  this.page.url = "http://www.qiwenke.com/2017/07/02/ECMAScript5-1-10-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/";  // Replace PAGE_URL with your page's canonical URL variable
  this.page.identifier = "http://www.qiwenke.com/2017/07/02/ECMAScript5-1-10-%E5%8F%AF%E6%89%A7%E8%A1%8C%E4%BB%A3%E7%A0%81%E5%92%8C%E6%89%A7%E8%A1%8C%E4%B8%8A%E4%B8%8B%E6%96%87/"; // Replace PAGE_IDENTIFIER with your page's unique identifier variable
  };
  (function() { // DON'T EDIT BELOW THIS LINE
  var d = document, s = d.createElement('script');
  s.src = 'https://qiwenke.disqus.com/embed.js';
  s.setAttribute('data-timestamp', +new Date());
  (d.head || d.body).appendChild(s);
  })();
  </script>
  <noscript>Please enable JavaScript to view the <a href="https://disqus.com/?ref_noscript" target="_blank" rel="noopener">comments powered by Disqus.</a></noscript>

</div>
<div class="post-catalog"></div>


<script src="/js/script.js"></script>


<script src="/js/prism.js"></script>
</body>
</html>