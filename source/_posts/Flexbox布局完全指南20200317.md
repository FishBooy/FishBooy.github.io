---
title: Flexbox布局完全指南 [译]
date: 2017-10-24 20:00:00
categories:
    - [技术, CSS, Flex]
tags:
    - [Flexbox]
---

Flexbox（弹性布局盒模型，W3C 规范中的术语叫作 flex layout box model）布局模式的目标在于提供一种解决方案，使得页面容器内的元素能够更加合理地布局、排列以及分配空间，尤其是针对内部子元素的宽度和高度未知或者动态变化的情况（这也是为什么用“弹性”来定义这种布局方式）。

Flexbox 的布局模式使得父元素有能力控制子元素的宽度或高度以及排列顺序，从而更好的填充父元素内的空间（尤其是在适配各种设备和屏幕尺寸的时候）。一个 flex 元素能够扩大子元素的尺寸来填满空间，也可以收缩元素的尺寸防止溢出。

最重要的一点，不同于常规的布局方式（基于纵向或横向），flexbox 布局是和方向无关的。尽管以前的一些常规布局方式也能满足页面的需求，但是在面对一些复杂的 web 应用的时候往往缺乏灵活性，尤其是在涉及到方向变化，尺寸扩展收缩等的时候。

> Flexbox 和 Grid 都是 css3.0 针对页面布局提出的新特性，两者的关键区别在于：Flexbox 布局属于一维布局，也就是说它只能在行或列上进行控制；Grid 则属于二维布局，它既能控制行也能控制列，是一个完整的网格系统。因此，Flexbox 布局用于页面上小范围的布局是合适的，比如某个组件。如果要对整个页面结构进行布局，Grid 布局模式则是最佳方案。

## 基础和术语

flexbox 布局是由一系列 css 属性集合起来才得以实现的，一部分属性是在父元素（也叫“弹性容器”）上设置的，另一部分则是在子元素上设置的（“弹性元素”）。

如果常规的布局是以块元素和内联元素为基础的文档流，那么 flexbox 布局则是以以弹性元素为基础的弹性流。下面的插图（来自 W3C HTML 规范）揭示了基于弹性布局的原理：

![flebox](https://css-tricks.com/wp-content/uploads/2018/11/00-basic-terminology.svg)

因此，容器内的子元素是按照 main axis（主轴，从 main-start 到 main-end）或 cross axis（纵轴，从 cross-start 到 cross-end）依次排列的。

-   **main axis** - 主轴，即当前子元素按照这条轴线的方向排列。main axis 不是固定的，使用“flex-direction”属性可以改变元素主轴方向（水平和垂直两种，默认是水平方向）。
-   **main-start | main-end** - 元素从 main-start 的位置开始朝 main-end 的方向排列。
-   **main size** - 一个弹性容器或弹性元素的宽或高，如果 main-axis 是水平方向那么 main-size 等同于元素的 width 值，如果是纵向则是元素的 height 值。
-   **cross axis** - 和主轴线相垂直的轴线
-   **cross-start | cross-end** - 当元素按照 cross axis 排列的时候，会从 cross-start 开始朝 cross-end 的方向排列。
-   **cross size** -一个弹性容器或弹性元素的宽或高，如果 cross-axis 是水平方向那么 cross-size 等同于元素的 width 值，如果是纵向则是元素的 height 值。

## 属性介绍

### 父元素（弹性容器）的属性

![flex container](https://css-tricks.com/wp-content/uploads/2018/10/01-container.svg)

#### display

dispaly 属性是实现弹性布局的第一步，它使得父元素能够成为弹性容器，至于是内联还是块级则取决于具体的属性值。需要注意的是：在一个弹性容器中使用 coloums 属性是无效的。

```css
.container {
    display: flex; /* 或者inline-flex */
}
```

#### flex-direction

![flex-direction](https://css-tricks.com/wp-content/uploads/2018/10/flex-direction.svg)

该属性定义了主轴线 main-axis 的方向，也就是容器内子元素的排列方向。flexbox 是单向布局的，元素只能在水平和竖直中选择一个方向进行排列。

```css
.container {
    flex-direction: row | row-reverse | column | colum-reverse;
}
```

-   **row （默认）**:  水平的自左向右排列
-   **row-reverse**: 水平的自右向左排列
-   **column**: 竖直的自上而下排列
-   **column-reverse**: 竖直的自下而上排列

#### flex-wrap

![flex-wrap](https://css-tricks.com/wp-content/uploads/2018/10/flex-wrap.svg)

子元素默认会在沿着 flex-direction 的方向一直排列，而使用 flex-wrap 属性则可以使元素进行换行排列（在所有元素排列长度超过父元素宽度时）。

```css
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```

-   **nowrap (默认)**: 所有元素都会排列在一条线上
-   **wrap**: 当元素排列到行尾或列尾时会进行换行或换列继续排
-   **wrap-reverse**: 以 wrap 的反方向排列

> 注：当 flex-direction 为 row 或者 row-reverse 的时候（也就是 main-axis 是水平方向时），如果父元素 flex-wrap 值为 no-wrap 且子元素设置的 width 之和超过 main-size，那么子元素设置的 with 属性会失效，所有子元素的宽度都等于：父元素宽度/子元素个数，如果仍然大于 main-size，那么子元素的 flex-shrink 属性就会生效，即元素会收缩至只够容纳自身 content（content+padding+border）的宽度。

#### flex-flow

flex-flow 是 flex-direction 和 flex-wrap 合并的缩写属性，默认属性值为“row nowrap”

#### justify-content

![justify-content](https://css-tricks.com/wp-content/uploads/2018/10/justify-content.svg)

该属性定义了子元素排列的对齐方式。当子元素是固定尺寸时，该属性能更好的利用父元素剩余的空间。即使元素溢出父元素，justify-content 的控制也依然有效。

```css
.container {
    justify-content: flex-start | flex-end | center | space-between |
        space-around | space-evenly;
}
```

-   **flex-start (默认)**: 元素朝着排列的起始方向对齐（左对齐或上对齐）
-   **flex-end**: 元素朝着排列的结束方向对齐（右对齐或下对齐）
-   **space-between**: 元素被均匀排列在轴线上，元素之间的距离相等。
-   **space-around**: 每个元素的左右（横向排列时）或上下（纵向排列时）都被分配了相等的空间。
-   **space-evenly**: 元素被均匀排列，元素与元素之间的距离、元素和边界(main-start/main-end/cross-start/cross-end) 之间的距离是相等的。

> 注：如果子元素设置了 margin:auto，则父元素的 justify-content 的属性值会被覆盖为 space-around。在上文中使用到及下文不断会提到的“剩余空间”，它指的是在 main-axis 方向上减去去所有元素排列的长度之后余下的尺寸。如果 main-axis 是水平方向，那么每一行的剩余空间就是 main-size 减去元素排列总宽度后剩余的宽度；如果 main-axis 是竖直方向，同理，剩余空间就代表了 main-size 和元素排列的高度差。

#### align-items

![align-items](https://css-tricks.com/wp-content/uploads/2018/10/align-items.svg)

这个属性定义了子元素在 cross-axis 的方向上是如何对齐的。

```css
.container {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

-   **flex-start**: 元素在 cross-axis 方向上以 flex-start（cross-axis 的 flex-start）为准进行对齐。
-   **flex-end**: 元素在 cross-axis 方向上以 flex-end（cross-axis 的 flex-end）为准进行对齐。
-   **center**: 元素在 cross-axis 方向上居中对齐。
-   **baseline**: 元素在 cross-axis 方向上用基线（每个子元素的内容的首行的底线）对齐。
-   **stretch (默认)**:  元素的 cross-size 伸展到等同于整个父元素在 cross-axis 方向上的尺寸。

#### align-content

![align-content](https://css-tricks.com/wp-content/uploads/2018/10/align-content.svg)

当 cross-axis 方向上除元素占据的空间还有多余的空间时，该属性会将这些空间进行合理分配（类似于上文中控制 main-axis 的 justify-content）。该属性针对的是子元素有多行排列的情况，如果父元素内的元素排列只有一行，该属性定义无效。

```css
.container {
    align-items: flex-start | flex-end | center | baseline | stretch;
}
```

-   **flex-start**: 元素在 cross-axis 的方向上以 flex-start（cross-axis 的 flex-start）为准进行对齐，剩余空间全部在 flex-end 一侧。
-   **flex-end**: 元素在 cross-size 的方向上以 flex-end（cross-axis 的 flex-end）为准进行对齐，剩余空间全部在 flex-end 一侧。
-   **center**: 元素在 cross-size 的方向上居中对齐，剩余空间一分为二分布在 flex-start 和 flex-end 两侧。
-   **space-between**: 元素被均匀排列在 cross-axis 上，元素之间的距离相等。
-   **space-around**: 每个元素的左右（cross-axis 为横向时）或上下（cross-axis 为纵向时）都被分配了相等的空间。
-   **stretch**: 元素被均匀的拉伸以完全占用 cross-axis 方向上的剩余尺寸。

### 子元素（弹性元素）的属性

![flex item](https://css-tricks.com/wp-content/uploads/2018/10/02-items.svg)

#### order

![order](https://css-tricks.com/wp-content/uploads/2018/10/order.svg)

子元素默认是按照 html 中的标签顺序依次排列的，但是“order”属性可以改变元素在页面中显示出来的排列顺序（DOM 中的层次顺序不会发生变化）。

```css
.item {
    order: <integer>; /*任意整数值 默认为0 值越小越对应的元素越靠前排列*/
}
```

#### flex-grow

![flex-grow](https://css-tricks.com/wp-content/uploads/2018/10/flex-grow.svg)

当在 main-axis 方向上有剩余空间时，子元素会按照各自的 flex-grow 的属性值按比例扩大尺寸以充分分配剩余空间。如果所有子元素的 flex-grow 都设置为 1，那么剩余空间会被子元素均分。如果其中某个子元素的 flex-grow 设置为 2 而其他子元素设置为 1，那么该元素的增加的尺寸是其他元素增加尺寸的两倍。

```css
.item {
    order: <integer>; /*任意非负整数值 默认为0*/
}
```

#### flex-shrink

该属性与 flex-grow 产生的效果相反，对子元素产生收缩尺寸的效果，这种情况通常发生 main-axis 为水平方向且子元素的宽度之和超过 main-size 时（参考上文 flex-wrap 中的注释）。

```css
.item {
    flex-shrink: <integer>; /*任意非负整数值 默认为0*/
}
```

#### flex-basis

该属性效果相当于 width 属性。当子元素设置了 flex-grow 属性时，在 main-axis 方向上剩余的空间会根据 flex-grow 的属性值按比例分配给子元素。如果子元素同时设置了 flex-basis 属性，那么在计算剩余空间时，main-size 减去的不是子元素在页面上的宽/高度而是其 flex-basis 的值。flex-basis 的值可以是具体的长度（比如 20%、5rem、100px 等），也可以是关键字“auto”。当 flex-basis 设置为 0 时，子元素的尺寸会在剩余空间分配完毕后的长度取自身内容的宽/高和分配到尺寸宽/高的最大值。

```css
.item {
    flex-basis: <length> | auto; /*默认为auto*/
}
```

#### flex

该属性是 flex-grow、flex-shrink、flex-basis 合并的缩写，其中后两个属性的值是可选的。默认值为“0 1 auto”。

```css
.item {
    flex: none | [< 'flex-grow' > < 'flex-shrink' >? || <flex-basis>];
}
```

#### align-self

![align-self](https://css-tricks.com/wp-content/uploads/2018/10/align-self.svg)

上文中父元素的 align-items 属性是对所有子元素在 main-axis 方向上进行对齐，而子元素的 align-self 属性可以使自身的对齐方式覆盖 align-items 定义的方式。该属性取值在 align-items 取值的基础上增加了一个关键字“auto”（继承 align-items 属性值）。

> 关于弹性元素（flex 元素内的子元素），需要注意的是其设置的 float、clear、vertical-align 属性都会失效。

## 应用示例

css 布局中有一个很常见的问题：完全居中（子元素水平和垂直都居中）。用 flex 布局来实现会非常简单。

```css
.container {
    display: flex;
    height: 400px; /*设置固定高度或auto*/
}
.item {
    width: 100px;
    height: 100px; /*设置固定高度 如果没有固定高度 默认的align-items:stretch会使其高度与父元素保持一致*/
    margin: auto;
}
```

margin 的作用非常关键，它分摊了水平和垂直方向上的宽和高并平均分布在左右和上下，从而使得子元素能够完全居中。

> 注：如果子元素不使用 margin 属性，那么给父元素设置“justify-content:center;align-items:center;”同样可以达到完全居中的效果。

网站顶部的导航链接也是一个常见布局。如果需要导航在大尺寸的屏幕上居右显示而小屏幕上整行显示，可以参考下面的设置（建议在 CodePen 中拖拽浏览器屏幕，查看不同尺寸屏幕下的样式效果）：

See the Pen Demo Flexbox 2 by CSS-Tricks (@css-tricks) on CodePen.

## 样式前缀

由于 flex 规范提出之后，历经了多个版本，且截止到目前仍然没有形成稳定的版本，因此各浏览器厂商对其支持程度不同，这也导致了在不同的浏览器下 flex 的属性需要添加不同的前缀（不仅仅是属性值需要添加，属性名也需要添加前缀）。针对前缀问题的解决方案可以参考 Autoprefixer。

## 参考

-   Flexbox in the CSS specifications
-   Flexbox at Opera
-   Diving into Flexbox by Bocoup
-   Mixing syntaxes for best browser support on CSS-Tricks
-   Flexbox by Raphael Goetter (FR)
-   Flexplorer by Bennett Feely

> 原文信息地址：A Complete Guide to Flexbox 作者：Chris Coyier

## 结语

Flexbox 的布局方案最早是由 W3C 在 2009 年起草的，但是到目前为止，该方案仍然不是 W3C 的推荐标准（REC-Recommendation）而是候选标准（CR-Candidate Recommencation），候选标准意味着该方案仍然有被替换或者废除的可能。不过基于 W3C 规范的滞后性以及当前各主流浏览器的支持和实现，flexbox 的布局方案已经成为事实上的标准。

[查看 flexbox 的兼容性](https://caniuse.com/#feat=flexbox)。尽管支持度已经是标准的级别，但 IE 仍然不出意料的拖了后腿。因此，是否在应用中完全使用 flex 的布局方式仍然需要开发者在进行综合考量之后再做决定。

> **原文地址**：<https://css-tricks.com/snippets/css/a-guide-to-flexbox/>  
> **翻译备注**：原文中关于 flex 当前的兼容性问题介绍的比较简短，因此本文中删掉了该部分并使用 canIuse 的数据进行了补充说明。此外，关于“样式前缀”部分，原文中有更详尽的解释，建议阅读原文并查看 Autoprefixer 的链接文章。
