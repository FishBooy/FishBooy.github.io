---
title: Flexbox布局完全指南 [译]
date: 2017-10-24 20:00:00
categories:
- [技术,CSS,Flex]
tags:
- [Flexbox]
---

Flexbox（弹性布局盒模型，W3C规范中的术语叫作flex layout box model）布局模式的目标在于提供一种解决方案，使得页面容器内的元素能够更加合理地布局、排列以及分配空间，尤其是针对内部子元素的宽度和高度未知或者动态变化的情况（这也是为什么用“弹性”来定义这种布局方式）。

Flexbox的布局模式使得父元素有能力控制子元素的宽度或高度以及排列顺序，从而更好的填充父元素内的空间（尤其是在适配各种设备和屏幕尺寸的时候）。一个flex元素能够扩大子元素的尺寸来填满空间，也可以收缩元素的尺寸防止溢出。

最重要的一点，不同于常规的布局方式（基于纵向或横向），flexbox布局是和方向无关的。尽管以前的一些常规布局方式也能满足页面的需求，但是在面对一些复杂的web应用的时候往往缺乏灵活性，尤其是在涉及到方向变化，尺寸扩展收缩等的时候。

>Flexbox和Grid都是css3.0针对页面布局提出的新特性，两者的关键区别在于：Flexbox布局属于一维布局，也就是说它只能在行或列上进行控制；Grid则属于二维布局，它既能控制行也能控制列，是一个完整的网格系统。因此，Flexbox布局用于页面上小范围的布局是合适的，比如某个组件。如果要对整个页面结构进行布局，Grid布局模式则是最佳方案。

## 基础和术语

flexbox布局是由一系列css属性集合起来才得以实现的，一部分属性是在父元素（也叫“弹性容器”）上设置的，另一部分则是在子元素上设置的（“弹性元素”）。

如果常规的布局是以块元素和内联元素为基础的文档流，那么flexbox布局则是以以弹性元素为基础的弹性流。下面的插图（来自W3C HTML规范）揭示了基于弹性布局的原理：

![flebox](https://css-tricks.com/wp-content/uploads/2018/11/00-basic-terminology.svg)

因此，容器内的子元素是按照main axis（主轴，从main-start到main-end）或cross axis（纵轴，从cross-start到cross-end）依次排列的。

- **main axis** - 主轴，即当前子元素按照这条轴线的方向排列。main axis不是固定的，使用“flex-direction”属性可以改变元素主轴方向（水平和垂直两种，默认是水平方向）。
- **main-start | main-end** - 元素从main-start的位置开始朝main-end的方向排列。
- **main size** - 一个弹性容器或弹性元素的宽或高，如果main-axis是水平方向那么main-size等同于元素的width值，如果是纵向则是元素的height值。
- **cross axis** - 和主轴线相垂直的轴线
- **cross-start | cross-end** - 当元素按照cross axis排列的时候，会从cross-start开始朝cross-end的方向排列。
- **cross size** -一个弹性容器或弹性元素的宽或高，如果cross-axis是水平方向那么cross-size等同于元素的width值，如果是纵向则是元素的height值。

## 属性介绍

### 父元素（弹性容器）的属性

![flex container](https://css-tricks.com/wp-content/uploads/2018/10/01-container.svg)

#### display

dispaly属性是实现弹性布局的第一步，它使得父元素能够成为弹性容器，至于是内联还是块级则取决于具体的属性值。需要注意的是：在一个弹性容器中使用coloums属性是无效的。

```css
.container {
    display: flex;/* 或者inline-flex */
}
```

#### flex-direction

![flex-direction](https://css-tricks.com/wp-content/uploads/2018/10/flex-direction.svg)

该属性定义了主轴线main-axis的方向，也就是容器内子元素的排列方向。flexbox是单向布局的，元素只能在水平和竖直中选择一个方向进行排列。

```css
.container {
    flex-direction: row | row-reverse | column | colum-reverse;
}
```

- **row （默认）**: 水平的自左向右排列
- **row-reverse**: 水平的自右向左排列
- **column**: 竖直的自上而下排列
- **column-reverse**: 竖直的自下而上排列

#### flex-wrap

![flex-wrap](https://css-tricks.com/wp-content/uploads/2018/10/flex-wrap.svg)

子元素默认会在沿着flex-direction的方向一直排列，而使用flex-wrap属性则可以使元素进行换行排列（在所有元素排列长度超过父元素宽度时）。

```css
.container {
    flex-wrap: nowrap | wrap | wrap-reverse;
}
```

- **nowrap (默认)**: 所有元素都会排列在一条线上
- **wrap**: 当元素排列到行尾或列尾时会进行换行或换列继续排
- **wrap-reverse**: 以wrap的反方向排列

>注：当flex-direction为row或者row-reverse的时候（也就是main-axis是水平方向时），如果父元素flex-wrap值为no-wrap且子元素设置的width之和超过main-size，那么子元素设置的with属性会失效，所有子元素的宽度都等于：父元素宽度/子元素个数，如果仍然大于main-size，那么子元素的flex-shrink属性就会生效，即元素会收缩至只够容纳自身content（content+padding+border）的宽度。

#### flex-flow

flex-flow是flex-direction和flex-wrap合并的缩写属性，默认属性值为“row nowrap”

#### justify-content

![justify-content](https://css-tricks.com/wp-content/uploads/2018/10/justify-content.svg)

该属性定义了子元素排列的对齐方式。当子元素是固定尺寸时，该属性能更好的利用父元素剩余的空间。即使元素溢出父元素，justify-content的控制也依然有效。

```css
.container {
    justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;
}
```

- **flex-start (默认)**: 元素朝着排列的起始方向对齐（左对齐或上对齐）
- **flex-end**: 元素朝着排列的结束方向对齐（右对齐或下对齐）
- **space-between**: 元素被均匀排列在轴线上，元素之间的距离相等。
- **space-around**: 每个元素的左右（横向排列时）或上下（纵向排列时）都被分配了相等的空间。
- **space-evenly**: 元素被均匀排列，元素与元素之间的距离、元素和边界(main-start/main-end/cross-start/cross-end) 之间的距离是相等的。

>注：如果子元素设置了margin:auto，则父元素的justify-content的属性值会被覆盖为space-around。在上文中使用到及下文不断会提到的“剩余空间”，它指的是在main-axis方向上减去去所有元素排列的长度之后余下的尺寸。如果main-axis是水平方向，那么每一行的剩余空间就是main-size减去元素排列总宽度后剩余的宽度；如果main-axis是竖直方向，同理，剩余空间就代表了main-size和元素排列的高度差。

#### align-items

![align-items](https://css-tricks.com/wp-content/uploads/2018/10/align-items.svg)

这个属性定义了子元素在cross-axis的方向上是如何对齐的。

```css
.container {
    align-items: flex-start | flex-end | center | baseline | stretch ;
}
```

- **flex-start**: 元素在cross-axis方向上以flex-start（cross-axis的flex-start）为准进行对齐。
- **flex-end**: 元素在cross-axis方向上以flex-end（cross-axis的flex-end）为准进行对齐。
- **center**: 元素在cross-axis方向上居中对齐。
- **baseline**: 元素在cross-axis方向上用基线（每个子元素的内容的首行的底线）对齐。
- **stretch (默认)**: 元素的cross-size伸展到等同于整个父元素在cross-axis方向上的尺寸。

#### align-content

![align-content](https://css-tricks.com/wp-content/uploads/2018/10/align-content.svg)

当cross-axis方向上除元素占据的空间还有多余的空间时，该属性会将这些空间进行合理分配（类似于上文中控制main-axis的justify-content）。该属性针对的是子元素有多行排列的情况，如果父元素内的元素排列只有一行，该属性定义无效。

```css
.container {
    align-items: flex-start | flex-end | center | baseline | stretch ;
}
```

- **flex-start**: 元素在cross-axis的方向上以flex-start（cross-axis的flex-start）为准进行对齐，剩余空间全部在flex-end一侧。
- **flex-end**: 元素在cross-size的方向上以flex-end（cross-axis的flex-end）为准进行对齐，剩余空间全部在flex-end一侧。
- **center**: 元素在cross-size的方向上居中对齐，剩余空间一分为二分布在flex-start和flex-end两侧。
- **space-between**: 元素被均匀排列在cross-axis上，元素之间的距离相等。
- **space-around**: 每个元素的左右（cross-axis为横向时）或上下（cross-axis为纵向时）都被分配了相等的空间。
- **stretch**: 元素被均匀的拉伸以完全占用cross-axis方向上的剩余尺寸。

### 子元素（弹性元素）的属性

![flex item](https://css-tricks.com/wp-content/uploads/2018/10/02-items.svg)

#### order

![order](https://css-tricks.com/wp-content/uploads/2018/10/order.svg)

子元素默认是按照html中的标签顺序依次排列的，但是“order”属性可以改变元素在页面中显示出来的排列顺序（DOM中的层次顺序不会发生变化）。

```css
.item {
    order: <integer> ;/*任意整数值 默认为0 值越小越对应的元素越靠前排列*/
}
```

#### flex-grow

![flex-grow](https://css-tricks.com/wp-content/uploads/2018/10/flex-grow.svg)

当在main-axis方向上有剩余空间时，子元素会按照各自的flex-grow的属性值按比例扩大尺寸以充分分配剩余空间。如果所有子元素的flex-grow都设置为1，那么剩余空间会被子元素均分。如果其中某个子元素的flex-grow设置为2而其他子元素设置为1，那么该元素的增加的尺寸是其他元素增加尺寸的两倍。

```css
.item {
    order: <integer> ;/*任意非负整数值 默认为0*/
}
```

#### flex-shrink

该属性与flex-grow产生的效果相反，对子元素产生收缩尺寸的效果，这种情况通常发生main-axis为水平方向且子元素的宽度之和超过main-size时（参考上文flex-wrap中的注释）。

```css
.item {
    flex-shrink: <integer> ;/*任意非负整数值 默认为0*/
}
```

#### flex-basis

该属性效果相当于width属性。当子元素设置了flex-grow属性时，在main-axis方向上剩余的空间会根据flex-grow的属性值按比例分配给子元素。如果子元素同时设置了flex-basis属性，那么在计算剩余空间时，main-size减去的不是子元素在页面上的宽/高度而是其flex-basis的值。flex-basis的值可以是具体的长度（比如20%、5rem、100px等），也可以是关键字“auto”。当flex-basis设置为0时，子元素的尺寸会在剩余空间分配完毕后的长度取自身内容的宽/高和分配到尺寸宽/高的最大值。

```css
.item {
    flex-basis: <length> | auto;/*默认为auto*/
}
```

#### flex

该属性是flex-grow、flex-shrink、flex-basis合并的缩写，其中后两个属性的值是可选的。默认值为“0 1 auto”。

```css
.item {
    flex: none | [<'flex-grow'> <'flex-shrink'>? || <flex-basis>];
}
```

#### align-self

![align-self](https://css-tricks.com/wp-content/uploads/2018/10/align-self.svg)

上文中父元素的align-items属性是对所有子元素在main-axis方向上进行对齐，而子元素的align-self属性可以使自身的对齐方式覆盖align-items定义的方式。该属性取值在align-items取值的基础上增加了一个关键字“auto”（继承align-items属性值）。

>关于弹性元素（flex元素内的子元素），需要注意的是其设置的float、clear、vertical-align属性都会失效。

## 应用示例

css布局中有一个很常见的问题：完全居中（子元素水平和垂直都居中）。用flex布局来实现会非常简单。

```css
.container{
    display: flex;
    height: 400px;/*设置固定高度或auto*/
}
.item {
    width:100px;
    height:100px;/*设置固定高度 如果没有固定高度 默认的align-items:stretch会使其高度与父元素保持一致*/
    margin: auto;
}
```

margin的作用非常关键，它分摊了水平和垂直方向上的宽和高并平均分布在左右和上下，从而使得子元素能够完全居中。

>注：如果子元素不使用margin属性，那么给父元素设置“justify-content:center;align-items:center;”同样可以达到完全居中的效果。

网站顶部的导航链接也是一个常见布局。如果需要导航在大尺寸的屏幕上居右显示而小屏幕上整行显示，可以参考下面的设置（建议在CodePen中拖拽浏览器屏幕，查看不同尺寸屏幕下的样式效果）：

See the Pen Demo Flexbox 2 by CSS-Tricks (@css-tricks) on CodePen.

## 样式前缀

由于flex规范提出之后，历经了多个版本，且截止到目前仍然没有形成稳定的版本，因此各浏览器厂商对其支持程度不同，这也导致了在不同的浏览器下flex的属性需要添加不同的前缀（不仅仅是属性值需要添加，属性名也需要添加前缀）。针对前缀问题的解决方案可以参考Autoprefixer。

## 参考

- Flexbox in the CSS specifications
- Flexbox at Opera
- Diving into Flexbox by Bocoup
- Mixing syntaxes for best browser support on CSS-Tricks
- Flexbox by Raphael Goetter (FR)
- Flexplorer by Bennett Feely

>原文信息
>地址：A Complete Guide to Flexbox
>作者：Chris Coyier

## 结语

Flexbox的布局方案最早是由W3C在2009年起草的，但是到目前为止，该方案仍然不是W3C的推荐标准（REC-Recommendation）而是候选标准（CR-Candidate Recommencation），候选标准意味着该方案仍然有被替换或者废除的可能。不过基于W3C规范的滞后性以及当前各主流浏览器的支持和实现，flexbox的布局方案已经成为事实上的标准。

下面的数据显示了当前flexbox的兼容性：

Can I Use flexbox? Data on support for the flexbox feature across the major browsers from caniuse.com.

尽管支持度已经是标准的级别，但IE仍然不出意料的拖了后腿。因此，是否在应用中完全使用flex的布局方式仍然需要开发者在进行综合考量之后再做决定。

>翻译备注：原文中关于flex当前的兼容性问题介绍的比较简短，因此本文中删掉了该部分并使用canIuse的数据进行了补充说明。此外，关于“样式前缀”部分，原文中有更详尽的解释，建议阅读原文并查看Autoprefixer的链接文章。
