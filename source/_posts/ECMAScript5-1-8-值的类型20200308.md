---
title: ECMAScript5.1-(8)值的类型
date: 2017-06-19 20:00:00
categories:
- [技术,Javascript,ES5]
tags:
- [Javascript]
---

## 8.6 Object类型定义

一个object(Object实例，即对象)是一系列属性的集合，每个属性都是数据属性(Data property)，存取器属性(Accessor property)，内置属性(Internal property)中的一种。

- Data property 将属性名和一个任意类型的EL值以及一些值为Boolean类型的特性相关联。 它是最常规的属性，也就是对象字面量中的键值对。
- Accessor property 则将属性名和一个/两个访问函数以及一些值为Boolean类型的特性相关联，这些访问函数的作用在于设置该属性的值和读取该属性的值。
- Internal property 内置属性，没有显式的属性名且无法在程序中被直接访问。内置属性完全为ES规范所用，它在规范中的作用是解释程序的各种操作在内部是如何实现的。

### 8.6.1 命名属性的特性

在ES规范中，object的属性用property来表示，而用于描述某个property的特性则用attribute来表示。data property 和 accessor property 都是命名属性(都具有明确的属性名)，每个属性都由指定的特性集合来描述。下面的两个表格分别展示了这两类属性分别都有哪些特性。

[Table5- Attributes for Data property](http://www.test.com)

特性|特性值|特性描述
-|-|-
[[Value]]|任意类型的EL值|读取相应属性时的返回值。
[[Writable]]|Boolean|如果值为false，那么该属性的值将无法被更改。
[[Enumerable]]|Boolean|如果值为true，那么该属性将会被 for-in 枚举，反之则无法被枚举。
[[Configurable]]|Boolean|如果值为false，那么该属性无法被删除，无法被转化为Accessor property且属性的所有特性值([[Value]]除外)也无法被修改。

[Table6 - Attributes for Accessor property](http://www.test.com)

特性名|特性值|特性描述
-|-|-
[[Get]]|Object/ Undefined|如果该特性有值，则其值必须为函数。当读取该属性时，获取到的属性值就是函数的返回值。
[[Set]]|Object/ Undefined|如果该特性有值，则其值必须为函数。当每次设置该属性的值时，该函数就会以设置的值为唯一参数被调用。该属性通常是用来影响读取属性时返回的值，但这不是必须的。
[[Enumerable]]|Boolean|如果值为true，那么该属性将会被 for-in 枚举，反之则无法被枚举。
[[Configurable]]|Boolean|如果值为false，那么该属性无法被删除，无法被转化为Data property且属性的所有特性值([[Value]]除外)也无法被修改。

>Code Explanation

各属性的创建和读取、创建或设置：

```javascript
/*
** name,city,country,age,heigh是data property
** address,greet是accessor property
*/

/* 各类属性的创建 */
// 1) 字面量创建
var boy = {
    name: 'Calvin',
    city: 'Jinan',
    country: 'China',
    get address() {
        return this.city + this.country
    },
    set address(value) {
        this.city = value;
    }
}
// 2)表达式创建
// data property:
boy.age = 18;
boy['height'] = 175;
Object.defineProperty(boy, 'gender', { value: 'female' });

// accessor property
Object.defineProperty(boy, 'greet', {
    get: function() { return 'Hello world!' }
})

/* 各类属性的读取 - 相同 */
boy.name; // 'Calvin'
boy['age']; // 18
boy.address; // 'JinanChina'
boy['greet'] // 'Hello world

/* 各类属性的设置 - 相同 */
boy.name = 'Kevin';
boy['age'] = 16;

boy.address = 'Qingdao'; // boy.address -> 'QingdaoChina'
boy['greet'] = 'Hello'; // boy.greet -> 'Hello world'
```

对于Table5和Table6中列出的特性集合，这类集合是ES规范中规定的一种特殊类型(Property Descriptor)，但是EL提供了Object.getOwnPropertyDescriptor方法可以将其转化为object形式后返回。同时，EL也提供了defineProperty和defineProperties设置这些特性的值。如下：

```javascript
var boy = {
    name: 'Calvin',
    city: 'Jinan',
    country: 'China',
    get address() {
        return this.city + this.country
    },
    set address(value) {
        this.city = value;
    }
}
// 修改name属性的属性值且不可枚
Object.defineProperties(boy, {
    name: { value:'noName', enumerable: false }
});

for (prop in boy) {
    console.log(prop); // city country address
};

// 同时修改address和增加age属
Object.defineProperties(boy, {
    address: {
        get: function() { return 'USA' },
    },
    age: {
        value: 18,
        writable: false
    }
});
boy.address; // 'USA'
boy.age = 20;
boy.age; // 18
```

Object.getOwnPropertyDescriptor(obj, propName)的执行过程如下:

- 调用obj的内置方法[[GetOwnProperty]](下文Table8)，传入propName，获取对应的Property Descriptor(类型的值);
- 调用ES规范中的抽象操作FromPropertyDescriptor(Desc)，传入获取到的property descriptor(类型的值)，操作结果则是返回上图中的object。

Object.defineProperty(obj, propName, attrsObj)的执行如下：

- 调用抽象操作ToPropertyDescriptor(attrsObj)将attrsObj由object类型转换为property descriptor类型；
- 调用obj的内置方法[[DefineOwnProperty]]，传入属性名propName和转换后的property descriptor作为参数，执行为obj设置属性的操作。

Objec.defineProperties(obj, propList)方法只是将各属性及其特性放在了同一对象中进行处理，原理和defineProperty相同。

> Code Explanation End

### 8.6.2 内置属性和方法

ES规范中定了各种内置属性和方法，这些属性和方法并不是EL的一部分，它们的存在只是为了方便规范对一些实现语言的行为进行解释说明，这些实现语言必须必须依照规范中定义的内置属性和方法的工作原理去执行操作。

Table8中列出了所有ES objects都有的内置属性和方法，Table9中列出的则是只有个别ES objects才会有的内置属性和方法。表中的“any“指的是任意类型的EL值，“Primitive“指的是原始值，即除去Object后的EL值：Number,String,Boolean,Undefined,Null。“SpecOp“指的是当前的内置属性是一个内置方法，所以SpecOp中可能会传入一些参数，如果参数名和某类值的类型名相同，则表示该参数需要是该类型的值。如果该内置方法执行后(SpecOp(...))会返回值则用“→“加返回值的类型表示。“Property Descriptor“是一种ES规范类型，它的值是描述object命名属性的特性集合(Table8 & Table9)。

[Table8 - ES objects的公共内置属性]()

内置属性|属性值|属性描述
-|-|-
[[Prototype]]|Object/null|object的原型。
[[Class]]|String|object所属类的类名。
[[Extensible]]|Boolean|如果为true，表示可以为object增加命名属性
[[Get]]|SpecOp(propertyName)→any|返回object命名属性的属性值。
[[GetOwnProperty]]|SpecOp(propertyName)→Property Descriptor/Undefined|返回描述object自身的命名属性的特性集合，如果属性不存在则返回undefined。
[[GetProperty]]|SpecOp(propertyName)→Property Descriptor/Undefined|返回描述object包含属性的特性集合，如果属性不存在则返回undefined。
[[Put]]|SpecOp(propertyName, any, Boolean)→Boolean|为object名为propertyName的属性赋值，属性值为any，Boolean负责标记是否需要赋值失败的处理。
[[CanPut]]|SpecOp(propertyName)→Boolean|返回一个布尔值，true表示可以为object的属性propertyName执行[[Put]]操作，反之则表示不可以
[[HasProperty]]|SpecOp(propertyName)→Boolean|返回一个布尔值，表示object是否有propertyName这个属性。
[[Delete]]|SpecOp(propertyName, Boolean)→Boolean|删除object的命名属性propertyName，Boolean表示是否需要删除失败的处理。
[[DefaultValue]]|SpecOp(Hint, Boolean)→Primitive|Hint是一个字符串。为object返回一个原始值。
[[DefineOwnProperty]]|SpecOp (propertyName, PropertyDescriptor, Boolean) → Boolean|用PropertyDescriptor增加或改变属性propertyName。

每个object的[[prototype]]属性都指向另一个object或null，ES语言就是靠[[Prototype]]实现的继承。objects之间靠该属性连接起来的继承链通常叫作原型链，每个原型链的长度必须是有限的，也就是说最终都会有一个顶层object的[[Prototype]]指向null，null不再有[[Prototype]]因此终结原型链。object的data property被继承后可以被读取但不可以被写入，而accessor property既可以被读取也可以被写入。

[[Extensible]]属性决定了object是否可以增加新的命名属性，如果值为false，则表示该object无法增加新属性且[[Class]]，[[Prototype]]属性也将无法被更改。[[Extensible]]一旦为false，就无法被设置回true了。

实际上，ES规范中并没有为实现语言规定可以更改[[Extensible]]，[[Class]]，[[Prototype]]的操作符或内置方法，如果某种实现语言要提供这种方法，也必须以符合上文的描述为前提。

[[Class]]属性是为了标示出object所属的具体类别(Object类下的子类)，这些类别包含："Arguments", "Array", "Boolean", "Date", "Error", "Function", "JSON", "Math", "Number", "Object", "RegExp", and "String"。ES规范中只有通过“Object.prototype.toString“才能获取到[[Class]]的值。

除非另有规定，否则只要是ES规范中定义的对象都必须实现Table8中的内置属性和方法。Array objects具有自定义的[[DefineOwnProperty]]方法，String objects具有自定义的[[GetOwnProperty]]方法，Arguments objects则具有自定义的[[Get]]，[[GetOwnProperty]]，[[DefineOwnProperty]]内置方法，Function objects有自定义的[[Get]]方法。

[Table9 - 个别objects的特有内置属性]()

属性|属性值|属性描述
-|-|-
[[PrimitiveValue]]|Primitive|当前object的内部描述信息。在ES实现语言的object类型中，只有Number, String, Boolean, 和Date类型的object实现了该属性。
[[Construct]]|SpecOp(a List of any) →Object|通过new操作符被调用，创建一个object。接收的参数即new操作符执行时传入的参数。具有该属性的objects称为构造器(Constructors)。
[[Call]]|SpecOp(any, a List of any) →any|执行与当前object相关联的代码块。由函数调用表达式所触发。SpecOp接收的参数是当前对象和函数执行时传入的参数。具有该内置属性的objects是可调用的(Callable)。
[[HasInstance]]|SpecOp(any)→any|返回一个布尔值，表示传入的参数是否是由当前对象构造出来的(是否是其实例)。在EL中，只有函数对象具有该属性。
[[Scope]]|Lexical Environment|函数执行时所在的词法环境(Lexical Environment，ES规范中定义的类型)。EL中，只有函数对象具有该属性。
[[FormalParameters]]|List of Strings|一个可能为空的列表，该列表包含了函数的形参列表(FormalParametersList)中的标识符。EL中，只有函数对象具有该属性和[[FormalParametersList]]属性。
[[Code]]|ECMAScript Code|符合ES规范的代码段。只有函数对象具有该属性。
[[TargetFunction]]|Object|只有通过Function.proptotype.bind方法创建出来的函数对象具有该属性，该属性指向函数的目标函数。
[[BoundThis]]|any|只有通过Function.proptotype.bind方法创建出来的函数对象具有该属性，该属性指向函数被预绑定的this值。
[[BoundArguments]]|List of any|只有通过Function.proptotype.bind方法创建出来的函数对象具有该属性，该属性指向函数被预绑定的参数。
[[ParameterMap]]|Object|提供同一函数的参数对象的属性和形参之间的映射。只有函数对象的参数对象具有该属性。

## 8.12 Object内置方法的执行规则

设 O 为一个原生 object，P 为property description，Throw 为一个Boolean值，则各内置方法的执行规定如下所述。

### 8.12.1 [[GetOwnProperty]](P)

当O的内置方法[[GetOwnProperty]]被调用且传入属性名P为参数时，执行步骤如下：

如果O没有自有属性P则返回undefined。

1. 创建D为一个新的Property Description，不包含任何特性。
2. 获取X为O的属性P。
3. 如果X是data property，那么：
    - a. 设置D.[[Value]]为X.[[Value]]
    - b. 设置D.[[Writable]]为X.[[Writable]]
4. 如果X是accessor property，那么：
    - a. 设置D.[[Get]]为X.[[Get]]
    - b. 设置D.[[Set]]为X.[[Set]]
    - 设置D.[[Enumerable]]为X.[[Enumerable]]
    - 设置D.[[Configurable]]为X.[[Configurable]]
5. 如果O是一个String object, String类型下重写了[[GetOwnProperty]]方法，更为复杂一些，参考15.5.5.2。

### 8.12.2 [[GetProperty]](P)

1. 当O的内置方法[[GetProperty]]被调用且传入属性名P为参数时，执行步骤如下：
2. 获取prop为O.[[GetOwnProperty]](P)的返回值。
3. 如果prop不是undefined，则返回prop。
4. 获取prop为O.[[Prototype]]。
5. 如果prop是null，则返回undefined。
6. 返回prop.[[GetProperty]](P)的返回值。

### 8.12.3 [[Get]]

1. 当O的内置方法[[Get]]被调用且传入属性名P为参数时，执行步骤如下：
2. 获取desc为O.[[GetProperty]](P)的返回值。
3. 如果IsDataDescriptor(desc)为true，则返回desc.[[Value]]。
4. 否则IsAccessorDescriptor(desc)一定为true，设getter为desc.[[Get]]。
5. 如果getter为undefined，则返回undefined。
6. 调用getter.[[Call]]，以O为this值且不传参，返回执行结果。

### 8.12.4 [[CanPut]](P)

### 8.12.5 [[Put]]

### 8.12.6 [[HasProperty]](P)

1. 当O的内置方法[[HasProperty]]被调用且传入属性名P为参数时，执行步骤如下：
2. 获取desc为O.[[GetProperty]](P)的返回值。
3. 如果desc为undefined则返回false.
4. 反之返回true。

### 8.12.7 [[Delete]]

### 8.12.8 [[DefaultValue]] (hint)

- 当O的内置方法[[DefaultValue]]被调用，且传入的hint为String时，执行步骤如下：

1. 调用O的内置方法[[Get]]，传入参数“toString“，设返回结果为toString。如果IsCallable(toString)为true，则：
    - a. 以O为this值，调用toString的内置方法[[Call]]，无其他参数传入，设返回结果为str。
    - b. 如果str是基本类型的值，则返回str。
2. 调用O的内置方法[[Get]]，传入参数“valueOf“，设返回结果为valueOf。如果IsCallable(valueOf)为true，则：
    - a. 以O为this值，调用valueOf的内置方法[[Call]]，无其他参数传入，设返回结果为val
    - b. 如果val是基本类型的值，则返回val。
3. 抛出TypeError异常。

- 当O的内置方法[[DefaultValue]]被调用，且传入的hint为Number时，执行步骤如下：

1. 调用O的内置方法[[Get]]，传入参数“valueOf“，设返回结果为valueOf。如果IsCallable(valueOf)为true，则：
    - a. 以O为this值，调用valueOf的内置方法[[Call]]，无其他参数传入，设返回结果为val。
    - b. 如果val是基本类型的值，则返回val。
2. 调用O的内置方法[[Get]]，传入参数“toString“，设返回结果为toString。如果IsCallable(toString)为true，则：
    - a. 以O为this值，调用toString的内置方法[[Call]]，无其他参数传入，设返回结果为str
    - b. 如果str是基本类型的值，则返回str。
3. 抛出TypeError异常。

- [[DefaultValue]]被调用时，如果hint值未传入，则默认为Number，当O为Date object时除外(此时hint为String)。[[DefaultValue]]只允许返回基本类型的值，如果任意其他类型的宿主对象要实现自己的[[DefaultValue]]方法，必须确保最终的返回值为基本类型的值。

>Code Explanation

[[DefaultValue]]的操作，简单来讲就是按顺序(由hint决定)依次调用object的toString，valueOf方法直到返回一个基本类型的值为止。

```javascript
var arr = [1, 2, 3];
// hint值默认为Number 因此首先调用valueOf
arr.valueOf(); // [1, 2, 3]
arr.toString(); // "1,2,3"
// 所以arr.[[DefaultValue]]()的结果为 "1,2,3"
```

>Code Explanation End

### 8.12.9 [[DefineOwnProperty]](P, Desc, Throw)

- 当O的内置方法[[DefineOwnProperty]]被调用，且分别传入参数：属性名P，property descriptor Desc，Boolean标识Throw时，执行步骤如下：

1. 设current为O.[[GetOwnProperty]](P)的返回值。
2. 设extensible为O.[[Extensible]]。
3. 如果current为undefined，extensible为false，则Reject。
4. 如果current为undefined，extensible 为true，那么：
    - a. 如果IsGenericDescriptor(Desc) 或者 IsDataDescriptor(Desc) 为true，那么：
        - i. 创建一个名为P的data property，该属性的特性集合([[Value]], [[Writable]], [[Enumerable]], [[Configurable]])与Desc保持一致。如果Desc中有缺失的特性，则新创建的属性中的对应特性被设置为默认值。
    - b. 否则，Desc一定是一个accessor Property Descriptor，那么：
        - i. 创建一个名为P的accessor property，该属性的特性集合([[Get]], [[Set]], [[Enumerable]], [[Configurable]])与Desc保持一致。如果Desc中有缺失的特性，则
       新创建的属性中的对应特性被设置为默认值。
    - c. 返回true。
5. 返回true，如果Desc中不包含任何特性值。
6. 返回true，如果Desc中的特性值和current中的一致。
7. 如果current中的[[Configurable]]为false，那么：
    - a. Reject， 如果Desc中[[Configurable]]为true
    - b. Reject，如果Desc中[[Enumerable]]的值和current中[[Enumerable]]的值互为相反的布尔值。
8. 如果IsGenericDescriptor(Desc)为true，不进行其他验证。
9. 否则，如果IsDataDescriptor(current)且IsDataDescriptor(Desc)有不同的返回值，那么：
    - a. Reject，如果current中[[Configurable]]为false。
    - b. 如果IsDataDescriptor(current)为true，那么：
        - i. 将O的属性P由data property转化为accessor property。保留已有的[[Configurable]]和[[Enumerable]]值，剩余特性值设为默认值。
    - c. 否则：
        - i. 将O的属性P由accessor property转化为data property。保留已有的[[Configurable]]和[[Enumerable]]值，剩余特性值设为默认值。
10. 否则，如果IsDataDescriptor(current)和IsDataDescriptor(Desc)的值都为true，那么：
    - a. 如果current中[[Configurable]]为false，那么：
        - i.  Reject，如果current中[[Writable]]为false且Desc中[[Writable]]为true。
        - ii. 如果current中的[[Writable]]为false，那么：
        - iii. Reject，如果current.[[value]]和Desc.[[Value]]不是相同值
    - b. 否则，如果current中的[[Configurable]]为true，那么任何属性改变都是允许的。
11. 否则，如果IsAccessorDescriptor(current)和IsAccessorDescriptor(Desc)都为true
    - a. 如果current中[[Configurable]]为false，那么：
        - i. Reject，如果current.[[Get]]和Desc.[[Get]]不是相同值
        - ii. Reject，如果current.[[Set]]和Desc.[[Set]]不是相同值
12. 遍历Desc中的特性，并将O.P的对应特性设置为该特性的值。
13. 返回True。