---
title: ECMAScript5.1-(10)可执行代码和执行上下文
date: 2017-07-02 20:00:00
categories:
- [技术,Javascript,ES5]
tags:
- [Javascript]
---

## 10.1 可执行代码的类型

在ES规范中有三种可执行代码：

- _Global code_ 即ES Program的源文本。一个Program的代码不包含任何可被解析为FunctionBody的文本。
- _Eval code_ 内置函数eval被调用时传入的文本。
- _Function code_ 被解析为FunctionBody的源文本。FunctionBody中的function code不包含任何内层的可被解析为FunctionBody的源文本。当内置的Function方法作为构造函数被调用时，最后一个参数会被转化为字符串后也被当作FunctioBody.

## 10.2 Lexical Environment

Lecical Environment(简称LE)是一种规范类型，该类型以代码的词法嵌套结构为基础，定义了指定变量、函数与标志符的关联关系。一个LE由Environment Record(简称ER)和一个可能为空的outer LE组成。通常一个LE是和指定的code相关联的，比如FunctionDelcaration，WithStatement，TryStatement的Catch从句，这些代码每执行一次就会生成一个新的Lecical Environment。

一个Environent Record记录了相关联的LE作用域内的identifier bindings。

内层LE的outer LE，是对在词发上包裹内层LE的LE的引用。一个outer LE也会有自己的outer LE。一个LE可以作为多个内层LE的outer LE。比如，一个在一个FunctionDeclaration内包含了两个FunctionDeclarations，那么这两个函数声明的outer LE会共享一个LE，即外层的LE。

LE和ER是ES规范的内部实现类型，仅供规范使用无法通过任何代码进行使用。

### 10.2.1 Environment Records

此规范中有两种ER，declarative enbironment records(简称DER)和objcet environment records(简称OER)。DER作用于ES规范中的语法元素有FunctionDeclaration，VariableDeclarations，Catch从句，它将identifiers bindings和ES类型值相关联。OER则作用于ES Program和WithStatement，它将iderntifiers binding和某个对象的属性相关联。

在规范中，可以用面向对象的方式理解ER。ER是一个抽象类，它作为父类被DER和OER继承。ER作为抽象类，包含了Table 17中的抽象操作方法，而每个子类负责对这些方法进行具体实现。

Table 17-ER的抽象方法

方法|作用
-|-
HasBinding(N)|判断一个ER是否有针对某个标志符的binding，如果有责则返回true，否则返回false。N是标志符的字符串名称。
CreateMutableBinding(N,D)|在ER中创建一个可变binding。N是bound name。如果可选布尔参数D为true，那么创建的binding可以被随后的操作删除。
SetMutableBinding(N,V,S)|对ER中已经存在的binding进行设置。N是bound name，V是将要设置给binding的值，该值可以是ES语言的任何类型的值。S是一个布尔标识，如果S为true，那么binding无法被设置且抛出异常TyperError。
GetBindingValue(N,S)|返回ER中已存在的binding的值。N是bound name。S用于标识是否为严格模式，如果S为true且当前binding不存在或未被初始化，则抛出异常ReferenceError。
Deletebinding(N)|在ER中删除binding。N是bound name，如果N的binding存在则删除该binding并返回true。如果binding存在但不能被删除则返回false。如果binding不存在返回true。
ImplicitThisValue()|返回一个值，当ER中的某个binding值为函数且被调用时，该值作为函数的this值。

#### 10.2.1.1 Declarative Environment Records

每个DER都与包含变量和/或函数声明的ES代码作用域相关。一个DER包装了它作用域内的标识符。

除了可变bindings，DER还提供了不可变bindings。对于不可变bindings，一旦标识符和值之间的关联一旦建立就不能再被更改。不可变bindings的创建和初始化是两个独立的步骤，因此对于不可变bindings，有可能处于初始化，也可能处于未初始化的状态。DER额外提供的方法在Table18中已列出。

Table 18-Declarative Environment Records的新增方法

方法|作用
-|-
CreateImmutableBinding(N)|在ER中创建一个新的但是未初始化的不可变binding。N是bound name。
InitializeImmutableBinding(N,V)|对ER中已存在但没有初始化的binding进行设置。N是bound name。V是要设置的值，可以是ES语言的任何类型值

#### 10.2.1.2 Object Environment Records

每个OER都与一个对象相关联，该对象称之为OER的binding object。一个OER包装的标识符，标识符名称与其binding object的属性名相对应。如果binding object的属性名是非标准标识符名，那么该属性会被OER所忽略。不管binding object包括其原型上的属性是否可枚举，都会被包装进OER之中。由于对象的属性可以动态的增加或删除，所以OER中的bindings也会对应的改变，任何受此动态影像产生的binding都被当作是可变binding，即使binding值的[[Writable]]属性为false。OER中不存在不可变binding。

### 10.2.2 Lexical Environment Operations

#### 10.2.2.1 GetIdentifierReference (lex, name, strict)

抽象操作GetIdentifierReference被调用时会传入：一个LE lex，一个标识符字符串name，一个布尔标识strict。lex的值可能为null。执行步骤如下：

1. 如果lex的值为null，那么
    - a. 返回一个Reference类型的值，该值的base value是undefined，referenced name是name，strict mode标识为strict。
2. 设envRec为lex's ER。
3. 调用envRec的HasBinding(N)方法，传入name作为参数。返回结果设为exists。
4. 如果exists为true，那么
    - a. 返回一个Reference类型的值，该值的base value是envRec，referenced name是name，strict mode标识为strict。
5. 否则
    - a. 设outer为lex's outer ER。
    - b. 返回GetIdentifierReference(outer,name,strict)的返回结果。

#### 10.2.2.2 NewDeclarativeEnvironment(E)

当抽象操作NewDeclarativeEnvironment(E)被调用时会传入：一个ER(可能为null) E。执行步骤如下：

1. 创建一个新的LE，设置为enc。
2. 设置envRec为一个新的不含任何binding的DER。
3. 将env的ER指向envRec。
4. 将env的outer ER指向E。
5. 返回env。

#### 10.2.2.3 NewObjectEnvironment(O, E)

当抽象操作NewObjectEnvironment被调用时会传入：一个对象O，一个ER(可能为null)E。执行步骤如下：

1. 设env为一个新创建的LE。
2. 设envRec为一个新的OER，该OER包含一个binding object O。
3. 将env的ER指向envRec。
4. 将env的outer ER指向E。
5. 返回env。

### 10.2.3 The Global Environment

global environment(简称ge)是唯一一个在ES代码执行前就已经被创建的LE。ge的ER是一个将全局对象作为binding object的OER。ge的outer ER是null。

在ES代码的执行过程中，全局对象有可能会增加新属性，原属性也有可能会被修改。

## 10.3 Execution Contexts

当代码的执行流进入某个可执行代码后，控制流就进入了某个execution context(执行上下文,简称EC)。活动的EC会组成一个执行栈。执行栈最顶层的EC就是当前正在执行的EC。当执行流从与当前EC相关联的可执行代码进入到另一个与当前EC无关的可执行代码后，就会产生一个新的EC。新的EC则会被压入执行栈成为当前正在执行的EC。

EC中包含了一系列的状态组件，这些组件用于追踪与其相关联的代码的执行情况。每个EC都会包含的三个状态组件，如下表Table 19所示。

Table 19 —Execution Context State Components

组件名|用途
-|-
LexicalEnvironment|指向用于对EC执行代码的识符引用进行解析的LE
VariableEnvironment|指向一个ER中的bindings完全由EC执行代码中的VariableStatements和FunctionDeclarations所产生的LE。
ThisBinding|在EC中的代码中this关键字的值

EC中的LexicalEnvironment(词法环境,简称LexEnv)和VariableEnvironment(变量环境,简称VarEnv)都是LE。当EC被创建后，LexEnv和VarEnv被初始化为同一个值。随着EC中代码的执行，VarEnv始终保持不变，而LexEnv则有可能因为代码的执行而发生改变。EC是属于ES规范的范畴，无法通过代码进行访问。

### 10.3.1 标识符解析(Identifier Resolution)

标识符解析是指用EC中的LexEnv确定与标识符相关的binding的过程。在ES代码的执行中，表达式：Identifier会按照以下步骤执行：

1. 设env为当前EC的LexEnv。
2. 如果当前代码是在严格模式下执行，那么设strict为true，否则设为false。
3. 返回GetIdentifierReference(env,Identifier,strict)的执行返回结果。

## 10.4 创建执行上下文

全局代码的执行和eval函数中传入的代码的执行都会创建并进入一个新的EC。每个函数代码的调用也会创建并进入一个新的EC，即使在函数递归调用自身的时候。每次return都会退出一个EC，抛出异常时会退出一个/多个EC。

当控制流进入一个EC，EC中的ThisBinding会被设置，VarEnv和初始LexEnv也会被定义，随后declaration binding instantiation(10.5)开始执行。具体的实现步骤取决于当前EC的执行代码类型。

### 10.4.1 进入全局代码

当控制流进入全局代码的执行上下文时：

1. 按10.4.1.1初始化EC
2. 使用全局代码执行10.5中的 Declaration Binding Instantiation。

#### 10.4.1.1

一个全局代码的EC会按照以下步骤进行初始化：

1. 设置VarEnv为全局环境Global Environment。
2. 设置LexEnv为全局环境Global Environment。
3. 设置ThisBinding为全局对象global object。

### 10.4.2 进入Eval代码

### 10.4.3 进入函数代码(Entering Function Code)

当执行流进入由函数对象F所包含的代码的EC时，同时有两个值会在调用时被提供，thisArg和argumentsList：

1. 如果函数代码处于严格模式，设置ThisBinding为thisArg。
2. 如果thisArg是null或者undefined，设置ThisBinding为全局对象global object。
3. 如果thisArg的类型不是对象，则设置ThisBinding为ToObject(thisArg)。
4. 设置ThisBinding为thisArg。
5. 设localEnv为调用NewDeclarativeEnvironment(F.[[Scope]])的返回值。
6. 设置LexEnv为localEnv。
7. 设置VarEnv为localEnv。
8. 设code为F的内置属性[[Code]]的值。
9. 用code和argumentsList执行10.5中的Declaration Binding Instantiation。

## 10.5 Declaration Binding Instantiation

每个EC都有一个VarEnv。在EC内执行的ES代码中声明的变量和函数都会作为bindings被添加到VarEnv的ER中。对于函数来讲，参数也会作为bindings被添加到ER中。

在哪个ER中添加bindings取决于在EC中执行的代码的类型，其余的操作都是通用的。当进入执行上文EC时，bindings会基于被提供的code，如果是函数还会有一个args，按照以下步骤在VarEnv中进行创建：

1. 设env为当前正在运行的EC的VarEnv的ER。
2. 如果code是eval代码，那么设configurableBindings为true，否则设为false。
3. 如果code处于严格模式，那么设strict为true，否则设为false。
4. 如果code是函数代码，那么
    - a. 设func为通过内部方法[[Call]]发起code执行的那个函数。设names为func's[[FormalParameters]]的值。
    - b. 以argName遍历names，如果argName在args中有对应的实参值，则设v为该值，否则设为undefined。调用env的HasBinding操作，传入argName，设返回结果为argAlreadyDeclared。
    - c. 如果argAlreadyDeclared为false，调用env的CreateMutableBinding方法传入argName作为参数。然后调用env的SetMutableBinding方法传入argName，v，strict作为参数。
5. 对于code中的每一个FunctionDeclaration：
    - a. 设fn为FunctionDeclaration中的Identifier。
    - b. 设fo为FunctionDeclaration按照ES规范13节中初始化得到的函数对象。
    - c. 设funcAlreadyDeclared为env's HasBinding(fn)的执行结果。
    - d. 如果funcAlreadyDeclared为false，调用env's CreateMutableBinding(fn,configurableBindings)。
    - e. 否则，如果env是global environment's ER那么：
        - i. 设go为全局对象
        - ii. 设existingProp为调用go的内置方法[[GetProperty]]并传入fn为参数的执行结果。
        - iii. 如果existingProp.[[Condigurable]]为true，那么调用go的内置方法[[DefineOwnProperty]]，传入fn，Property Descriptor{[[Value]]:undefined,[[Writable]]:true,[[Enumerable]]:true,[[Configurable]]:configurableBindings}，还有true作为参数。
        - iv. 否则，如果IsAccessorDescriptor(existingProp)或existingProp不符合{[[Writable]]:true,[[Enumerable]]:true}，那么抛出异常。
    - f. 调用env's SetMutableBinding(fn,fo,strict)。
6. 设argumentsAlreadyDeclared为env's HasBinding("arguments")的执行结果。
7. 如果code是函数代码，且argumentsAlreadyDeclared为false，那么
    - a. 设argsObj为CreateArgumentsObject(func,names,args,env,strict)的返回结果，即参数对象。
    - b. 如果strict为true，那么
        - i. 调用env's CreateImmutableBinding("arguments")。
        - ii. 调用env's InitializeImmutableBinding("arguments",argsObj)。
    - c. 否则
        - i. 调用env's CreateMutableBinding("arguments")。
        - ii. 调用env's SetMutableBinding("arguments",argsObj,false)。
8. 对于每个VariableDeclaration
    - a. 设dn为变量的标识符
    - b. 设varAlreadyDeclared为env's HasBinding(dn)的执行结果。
    - c. 如果为false，那么
        - i. 调用env's CreateMutableBinding(dn,configurableBindings)。
        - ii. 调用env's SetMutableBinding(dn,undefined,strict)。
