---
title: ECMAScript5.1-(13)函数的定义
date: 2017-07-06 20:00:00
categories:
- [技术,Javascript,ES5]
tags:
- [Javascript]
---

## 13 定义方式

**函数声明：function** _Identifier_ ( _FormalParameterList**opt**_ ) { _FunctionBody_ }
该声明会在声明绑定初始化的过程中按照以下方式进行初始化：

1. 使用 _FormalParameterList_ ，以及 _FunctionBody_ ，当前执行环境的**VariableEnvironment**作为 _Scope_ ，flag(如果声明是被包含在严格模式中或FunctionBody是严格模式则为**true**，否则则为**false**)作为参数，根据13.2创建出函数对象并返回。

**函数表达式1：function** ( _FormalParameterList**opt**_ ) { _FunctionBody_ }
初始化方式如下：

1. 使用 _FormalParameterList_  ，以及 _FunctionBody_ ，当前执行环境的**LexicalEnvironment**作为 _Scope_ ，Strict(如果表达式是被包含在严格模式中或FunctionBody是严格模式则为**true**，否则则为**false**)作为参数，根据13.2创建出函数对象并返回。

**函数表达式2：function** _Identifier_ ( _FormalParameterListopt_ ) { _FunctionBody_ } 初始化方式如下：

1. 调用NewDeclarativeEnvironment，传入当前执行环境的Lexical Environment作为参数，设创建出的新的词法环境为funcEnv。
2. 设 _envRec_ 为funcEnv的环境记录。
3. 调用 _envRec_ 的CreateImmutableBinding方法并传入Identifier作为参数。
4. 使用 _FormalParameterList_ ，以及 _FunctionBody_ ，_funcEnv_ 作为 _Scope_ ，_Strict_ (如果表达式是被包含在严格模式中或FunctionBody是严格模式则为**true**，否则则为**false**)作为参数，根据13.2创建出函数对象 _closure_ 。
5. 调用 _envRec_ 的InitializeImmutableBinding方法，传入  _Identifier_ 和 _closure_ 为参数。
6.返回 _closure_ 。

>函数表达式中的标识符Identifier可以在函数内被引用，这样就能实现函数自身的递归调用。不过不同于函数声明，Identifier只能在函数内部被引用不能在包含函数表达式的作用域内被引用，也无法影响其他作用域。

### 13.2 创建函数对象

给定可选参数列表 _FormalParameterList_ ，代码段 _FunctionBody_ ，一个词法环境(Lexical Environment) _Scope_ ， 一个布尔标识 _Strict_ 后，一个函数对象会按照下面的步骤进行构建：

1. 创建一个新的原生object，然后将F赋值为该object。
2. 按照8.12为F设置内置方法，[[Get]]除外。
3. 设置F的内置属性[[Class]]为字符串“**Function**“。
4. 设置F的内置属性[[Prototype]]为EL的内置对象**Function.prototype**。
5. 根据15.3.5.4设置F的内置属性[[Get]]
6. 根据13.2.1设置F的内置属性[[Call]]
7. 根据13.2.2设置F的内置属性[[Constructor]]
8. 根据15.3.5.3设置F的内置属性[[HasInstance]]
9. 设置F的内置属性[[Scope]]为 _Scope_ 。
10. 设置 _names_ 为一个列表，该列表包含了和 _FormalParameterList_ 中所有形参名相对应的字符串。如果形参为空，那么 _names_ 为空列表。
11. 设置F的内置属性[[FormalParameters]]为 _names_ 列表。
12. 设置F的内置属性[[Code]]为 _FunctionBody_ 。
13. 设置F的内置属性[[Extensible]]为**true**。
14. 设置len为 _FormalParameterList_ 中行参的个数，如果没有参数则设置 _len_ 为0。
15. 调用F的内置方法[[DefineOwnProperty]]，传入参数：“**length**“，{[[Value]]:_len_, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **true**}(Property Descriptor)， **false**。
16. 设置 _proto_ 为一个新的原生对象，该对象的创建方式与new Object()是一致的。
17. 调用 _proto_ 的内置方法[[DefineOwnProperty]，传入参数：“**Constructor**“，{[[Value]]: F, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **true**}(Property Descriptor)，**false**。
18. 调用F的内置方法[[DefineOwnProperty]]，传入参数：“**prototype**“，{[[Value]]: _proto_, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
19. 如果 _Strict_ 为**true**，那么：
    - a. 设置thrower为[[ThrowTypeError]]函数对象
    - b. 调用F的内置方法[[DefineOwnProperty]]，传入参数：“**caller**“，{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
    - c. 调用F的内置方法[[DefineOwnProperty]]，传入参数：“**arguments**“，{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
20. 返回F。

> 每个函数对象都会自动生成一个prototype属性，该属性确保该函数能够作为构造器使用。

#### 13.2.1 [[Call]]

当函数对象F的内置方法[[Call]]被传入参数一个this值和一个参数列表args，且被调用时，执行过程如下：

1. 使用传入的参数列表args和this值，以及F的内置属性[[FormalParameters]]，根据10.4.3中的描述为函数中的代码创建一个新的执行上下文 _funcCtx_。
2. 执行函数体，也就是F的内置属性[[Code]]。如果F没有[[Code]]或[[Code]]为空，那么执行结果result是(normal, undefined, empty)。
3. 退出当前执行上下文 _funcCtx_，恢复到之前的执行上下文。
4. 如果result.type是throw，抛出throw.value。
5. 如果result.type是return，返回result.value。
6. 否则result.type则是normal。返回**undefined**。

#### 13.2.2 [[Construct]]

当F的内置方法[[Construct]]被传入参数：一个可能为空的参数列表，并被调用时，执行过程如下：

1. 创建一个新对象obj。
2. 为 _obj_ 设置8.12 中规定的所有内置方法。
3. 设置 _obj_ 的内置属性[[Class]]为“**Object**“。
4. 设置 _obj_ 的内置属性[[Extensible]]为**true**。
5. 调用F的内置方法[[Get]]并传入参数“**prototype**“，设获取到的值为 _proto_。
6. 如果Type(_proto_)是Object，那么设置obj的内置属性[[Prototype]]为 _proto_。
7. 如果Type(_proto_)不是Object，那么创建一个新的空对象赋值给obj的内置属性[[Prototype]]。
8. 调用F的内置方法[[Call]]，obj为作为**this**值，以传入的参数列表作为args。设执行结果为 _result_。
9. 如果Type(result)为Object则返回 _result_。
10. 返回 _obj_。

#### 13.2.3 函数对象[[ThrowTypeError]]

[[ThrowTypeError]]对象是一个特殊的函数对象，它的定义如下：

1. 创建一个新对象F。
2. 为F设置8.12中定义的所有内置方法。
3. 设置F的内置属性[[Class]]为“**Function**“。
4. 设置F的内置属性[[Prototype]]为内置对象**Function.prototype**。
5. 设置F的内置方法[[Call]]，根据13.2.1。
6. 设置F的内置属性[[Scope]]为全局环境。
7. 设置F的内置属性[[FormalParameters]]为空列表。
8. 设置F的内置属性[[Code]]为一个代码体：该代码体只抛出**TypeError**异常，无其他操作。
9. 调用F的内置方法[[DefineOwnProperty]]，传入参数：“**length**“，{[[Value]]: 0, [[Writable]]: **false**, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，和**false**。
10. 设置F的[[Extensible]]为**false**。
11. 将F赋值给[[ThrowTypeError]]。
