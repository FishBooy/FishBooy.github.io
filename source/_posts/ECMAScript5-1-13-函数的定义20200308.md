---
title: ECMAScript5.1-(13)函数的定义
date: 2017-09-01 20:00:00
categories:
    - [技术, Javascript, ES5]
tags:
    - [Javascript]
---

## 13 定义方式

**函数声明：function** _Identifier_ ( _FormalParameterList**opt**_ ) { _FunctionBody_ } 该声明会在声明绑定初始化的过程中按照以下方式进行初始化：

1. 使用 _FormalParameterList_ ，以及 _FunctionBody_ ，当前执行环境的**VariableEnvironment**作为 _Scope_ ，flag(如果声明是被包含在严格模式中或 FunctionBody 是严格模式则为**true**，否则则为**false**)作为参数，根据 13.2 创建出函数对象并返回。

**函数表达式 1：function** ( _FormalParameterList**opt**_ ) { _FunctionBody_ } 初始化方式如下：

1. 使用 _FormalParameterList_ ，以及 _FunctionBody_ ，当前执行环境的**LexicalEnvironment**作为 _Scope_ ，Strict(如果表达式是被包含在严格模式中或 FunctionBody 是严格模式则为**true**，否则则为**false**)作为参数，根据 13.2 创建出函数对象并返回。

**函数表达式 2：function** _Identifier_ ( _FormalParameterListopt_ ) { _FunctionBody_ } 初始化方式如下：

1. 调用 NewDeclarativeEnvironment，传入当前执行环境的 Lexical Environment 作为参数，设创建出的新的词法环境为 funcEnv。
2. 设 _envRec_ 为 funcEnv 的环境记录。
3. 调用 _envRec_ 的 CreateImmutableBinding 方法并传入 Identifier 作为参数。
4. 使用 _FormalParameterList_ ，以及 _FunctionBody_ ，_funcEnv_ 作为 _Scope_ ，_Strict_ (如果表达式是被包含在严格模式中或 FunctionBody 是严格模式则为**true**，否则则为**false**)作为参数，根据 13.2 创建出函数对象 _closure_ 。
5. 调用 _envRec_ 的 InitializeImmutableBinding 方法，传入 _Identifier_ 和 _closure_ 为参数。 6.返回 _closure_ 。

> 函数表达式中的标识符 Identifier 可以在函数内被引用，这样就能实现函数自身的递归调用。不过不同于函数声明，Identifier 只能在函数内部被引用不能在包含函数表达式的作用域内被引用，也无法影响其他作用域。

### 13.2 创建函数对象

给定可选参数列表 _FormalParameterList_ ，代码段 _FunctionBody_ ，一个词法环境(Lexical Environment) _Scope_ ， 一个布尔标识 _Strict_ 后，一个函数对象会按照下面的步骤进行构建：

1. 创建一个新的原生 object，然后将 F 赋值为该 object。
2. 按照 8.12 为 F 设置内置方法，[[Get]]除外。
3. 设置 F 的内置属性[[Class]]为字符串“**Function**“。
4. 设置 F 的内置属性[[Prototype]]为 EL 的内置对象**Function.prototype**。
5. 根据 15.3.5.4 设置 F 的内置属性[[Get]]
6. 根据 13.2.1 设置 F 的内置属性[[Call]]
7. 根据 13.2.2 设置 F 的内置属性[[Constructor]]
8. 根据 15.3.5.3 设置 F 的内置属性[[HasInstance]]
9. 设置 F 的内置属性[[Scope]]为 _Scope_ 。
10. 设置 _names_ 为一个列表，该列表包含了和 _FormalParameterList_ 中所有形参名相对应的字符串。如果形参为空，那么 _names_ 为空列表。
11. 设置 F 的内置属性[[FormalParameters]]为 _names_ 列表。
12. 设置 F 的内置属性[[Code]]为 _FunctionBody_ 。
13. 设置 F 的内置属性[[Extensible]]为**true**。
14. 设置 len 为 _FormalParameterList_ 中行参的个数，如果没有参数则设置 _len_ 为 0。
15. 调用 F 的内置方法[[DefineOwnProperty]]，传入参数：“**length**“，{[[Value]]:_len_, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **true**}(Property Descriptor)， **false**。
16. 设置 _proto_ 为一个新的原生对象，该对象的创建方式与 new Object()是一致的。
17. 调用 _proto_ 的内置方法[[DefineOwnProperty]，传入参数：“**Constructor**“，{[[Value]]: F, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **true**}(Property Descriptor)，**false**。
18. 调用 F 的内置方法[[DefineOwnProperty]]，传入参数：“**prototype**“，{[[Value]]: _proto_, { [[Writable]]: **true**, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
19. 如果 _Strict_ 为**true**，那么：
    - a. 设置 thrower 为[[ThrowTypeError]]函数对象
    - b. 调用 F 的内置方法[[DefineOwnProperty]]，传入参数：“**caller**“，{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
    - c. 调用 F 的内置方法[[DefineOwnProperty]]，传入参数：“**arguments**“，{[[Get]]: thrower, [[Set]]: thrower, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，**false**。
20. 返回 F。

> 每个函数对象都会自动生成一个 prototype 属性，该属性确保该函数能够作为构造器使用。

#### 13.2.1 [[Call]]

当函数对象 F 的内置方法[[Call]]被传入参数一个 this 值和一个参数列表 args，且被调用时，执行过程如下：

1. 使用传入的参数列表 args 和 this 值，以及 F 的内置属性[[FormalParameters]]，根据 10.4.3 中的描述为函数中的代码创建一个新的执行上下文 _funcCtx_。
2. 执行函数体，也就是 F 的内置属性[[Code]]。如果 F 没有[[Code]]或[[Code]]为空，那么执行结果 result 是(normal, undefined, empty)。
3. 退出当前执行上下文 _funcCtx_，恢复到之前的执行上下文。
4. 如果 result.type 是 throw，抛出 throw.value。
5. 如果 result.type 是 return，返回 result.value。
6. 否则 result.type 则是 normal。返回**undefined**。

#### 13.2.2 [[Construct]]

当 F 的内置方法[[Construct]]被传入参数：一个可能为空的参数列表，并被调用时，执行过程如下：

1. 创建一个新对象 obj。
2. 为 _obj_ 设置 8.12 中规定的所有内置方法。
3. 设置 _obj_ 的内置属性[[Class]]为“**Object**“。
4. 设置 _obj_ 的内置属性[[Extensible]]为**true**。
5. 调用 F 的内置方法[[Get]]并传入参数“**prototype**“，设获取到的值为 _proto_。
6. 如果 Type(_proto_)是 Object，那么设置 obj 的内置属性[[Prototype]]为 _proto_。
7. 如果 Type(_proto_)不是 Object，那么创建一个新的空对象赋值给 obj 的内置属性[[Prototype]]。
8. 调用 F 的内置方法[[Call]]，obj 为作为**this**值，以传入的参数列表作为 args。设执行结果为 _result_。
9. 如果 Type(result)为 Object 则返回 _result_。
10. 返回 _obj_。

#### 13.2.3 函数对象[[ThrowTypeError]]

[[ThrowTypeError]]对象是一个特殊的函数对象，它的定义如下：

1. 创建一个新对象 F。
2. 为 F 设置 8.12 中定义的所有内置方法。
3. 设置 F 的内置属性[[Class]]为“**Function**“。
4. 设置 F 的内置属性[[Prototype]]为内置对象**Function.prototype**。
5. 设置 F 的内置方法[[Call]]，根据 13.2.1。
6. 设置 F 的内置属性[[Scope]]为全局环境。
7. 设置 F 的内置属性[[FormalParameters]]为空列表。
8. 设置 F 的内置属性[[Code]]为一个代码体：该代码体只抛出**TypeError**异常，无其他操作。
9. 调用 F 的内置方法[[DefineOwnProperty]]，传入参数：“**length**“，{[[Value]]: 0, [[Writable]]: **false**, [[Enumerable]]: **false**, [[Configurable]]: **false**}(Property Descriptor)，和**false**。
10. 设置 F 的[[Extensible]]为**false**。
11. 将 F 赋值给[[ThrowTypeError]]。
