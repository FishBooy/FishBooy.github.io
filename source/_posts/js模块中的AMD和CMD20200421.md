---
title: JS模块规范CommonJS和AMD
date: 2018-04-26 02:51:23
tags:
---

随着基于 Javascript 的 web 应用复杂性日益增加，命名空间和功能依赖这两个问题渐渐成为开发者的痛点。因此出现了各种解决这些问题的模块化方案，本文分析的就是当前被开发者普遍应用的一些模块化方案。

## 为什么需要模块化

在传统的客户端 js 开发环境中，各个 script 代码块间的依赖通常需要开发者手动地处理，保持各代码的正确的加载执行顺序，以确保在执行当前代码块前已经包含了自身需要而由其他代码块所提供的功能。

下面是一个使用 Backbone 的页面：

```html
<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <title>Backbone.js Todos</title>
        <link rel="stylesheet" href="todos.css" />
    </head>

    <body>
        <script src="../../test/vendor/json2.js"></script>
        <script src="../../test/vendor/jquery.js"></script>
        <script src="../../test/vendor/underscore.js"></script>
        <script src="../../backbone.js"></script>
        <script src="../backbone.localStorage.js"></script>
        <script src="todos.js"></script>
    </body>

    <!-- (...) -->
</html>
```

如果页面比较简单，大多数时候也不会有太大问题。但是随着 js 逻辑变得越来越复杂，体积也越来越大的时候，各代码块间的依赖管理就会变得非常麻烦。如果要增加新的功能，而新的功能又依赖其他功能，就要在保证新功能正常执行的同时又要兼顾到如何不影响原有的依赖顺序。而除此之外，另一个严重的问题就是变量命名，一个页面内通常会充斥着非常多的全局变量，代码量的增加很容易造成命名冲突而成为程序中的隐患。

最终，为了解决这些问题，js 模块化的解决方法得以出现。

## 临时解决方案：显示地自定义模块

在比较规范的模块化方案出现之前，定义一个显示的模块通常是开发者使用的一个解决办法。

```javascript
var myRevealingModule = (function () {
    var privateVar = 'Ben Cherry',
        publicVar = 'Hey there!';

    function privateFunction() {
        console.log('Name:' + privateVar);
    }

    function publicSetName(strName) {
        privateVar = strName;
    }

    function publicGetName() {
        privateFunction();
    }

    // 通过返回的对象暴露publicVar和publicSetName publicGetName
    // 通过暴露出的方法改变或读取私有变量privateVar的值 和 调用私有方法privateFunction
    return {
        setName: publicSetName,
        greeting: publicVar,
        getName: publicGetName,
    };
})();

myRevealingModule.setName('Paul Kinlan');
```

在 ES5 出现之前，函数基本上是 js 作用域的单位，每个函数都是一个块作用域，作用域内的变量只能在函数内部访问，外部无法访问。基于此，自定义模块这个办法采用的就是把数据封装在一个函数内并以单个对象的形式暴露给函数外部以使用。

这种模式曾经被采用过一段时间，它能一定程度上解决命名冲突的问题，但是并没有很好的处理依赖的问题。一个合理的模块化方案需要同时能解决掉这两个问题。

## CommonJS

CommonJs 这个项目的主要目的在于制定一系列规范以解决服务端 js(NodeJs)开发的问题。而它解决的其中一个问题就是模块的问题，Node.js 社区最初是遵循 CommonJs 规范的，但是最终实现出的是 NodeJs 自己的模块化方案，但是显然受到了 CommonJs 的影响。

```javascript
// 文件circle.js
const PI = Math.PI;
exports.area = (r) => PI * r * r;
exports.circumference = (r) => 2 * PI * r;

// 在其他文件中使用circle.js所产生的模块
const circle = require('./circle.js');
console.log(`The area of a circle of radius 4 is ${circle.area(4)}`);
```

在 Node.js 的模块系统顶层有一些抽象库，这些库一定程度上是 CommonJs 的实现。但在本文中，我们主要研究的还是两者具有共性的一些特性。

在 CommonJs 和 NodeJs 的模块系统中，有两个基本元素`require`和`exports`。`require`是一个函数，能在当前作用域内引入其他模块。`require`接收的参数为模块的 id，而在 Node 的实现中，参数是`node_modules`目录下的对应安装的模块的模块名，如果引用的模块不在该目录下，则参数可以是模块所在的路径。`exports`是一个特殊对象，其中的所有数据和方法最终会暴露出来作为使用接口。Node 和 CommonJs 有一个显著区别是，在 Node 中，`module.exports`是真正的最终暴露给公共的对象，而`exports`只不过是一个对它的引用，实际上`exports`在定义模块时只是一个局部变量。而在 CommonJs 中是没有`module.exports`的。

```javascript
// 无效的exports
// 给exports赋值 切断了对module.exports的引用
// 最终什么都不会暴露给外部
exports = {
    getArea: () => width ** 2,
};

// 有效的exports
module.exports = {
    getArea: () => width ** 2,
};

// 有效的exports
exports.getArea = (width) => width ** 2;
```

CommonJs 的模块化方案针对的是服务端 NodeJs 的开发，因此，它所提供的 API 都是同步执行的。也就是说，模块会以在文件中`require`进的顺讯加载和执行。

### 优势

-   简单易用，核心概念容易理解
-   很好的解决了依赖问题，只需要在当前模块内按需`require`对应的模块即可，但需要保证依赖模块的`require`顺序。
-   `require`可以在任何地方调用
-   支持循环依赖

### 缺点

-   同步执行的 API 对客户端不友好
-   一个模块就是一个文件
-   没有针对模块的构造方法(Node 是有的)
-   只能在运行时加载模块，不能在静态编译阶段进行分析

## 异步模块加载(AMD)

实际上 AMD 是早期从 CommonJs 项目分离出来的，因为一部分开发人员对 CommonJs 同步加载的实现方案不满意，因此最终诞生了 AMD。所以，AMD 和 CommonJs 的主要区别就是，AMD 支持异步记载模块。

```javascript
//调用define,传入由依赖模块组成的数组和一个包含当前模块数据的函数
define(['dep1', 'dep2'], function (dep1, dep2) {
    //返回值就是模块
    return function () {};
});

// 没有依赖时
define(function (require) {
    var dep1 = require('dep1'),
        dep2 = require('dep2');

    return function () {};
});
```

而 AMD 异步加载的实现则是基于 JS 中的闭包：当所有的依赖模块都加载完成之后，代表当前模块的函数才会开始执行。模块的定义和导入都是由 define 这个函数来决定的，在模块被定义后，其自身的依赖关系同时也得以明确。所以 AMD 的加载器能够在运行时对整个应用的依赖树有一个清晰的把握。而最重要的是，在定义模块时，没有依赖关系的库可以并行加载，这一点对于浏览器来说是非常重要的，因为它能够显著地提升整个应用的加载时间从而优化用户体验。

目前最主流的 AMD 实现有两个，[require.js](https://requirejs.org/)和[Dojo](https://dojotoolkit.org/)。`require.js`的使用比较直观，引入库文件，使用`script`标签上的`data-main`属性指明需要首先加载哪个模块。Dojo 的[加载步骤](https://dojotoolkit.org/documentation/tutorials/1.10/hello_dojo/index.html)也类似。

### 优势

-   异步加载带来了更快的加载时间
-   支持循环依赖
-   兼容`require`和`exports`
-   解决了依赖管理的问题
-   必要时模块可以分割到不同的模块
-   支持模块构造函数和插件(自定义加载步骤)

### 缺点

-   相比而言，语法稍微复杂一些
-   需要提前加载加载库
-   不支持静态编译阶段的分析

## ES2015 原生模块方案

最终，负责 JS 实现标准的 ECMA 小组决定彻底以原生支持的方式解决掉模块问题。最后的成果就是 ES2015 中的 modules 语法，该方案语法简明且同时兼容了异步和同步操作模式。

```javascript
//------ lib.js ------
export const sqrt = Math.sqrt;
export function square(x) {
    return x * x;
}
export function diag(x, y) {
    return sqrt(square(x) + square(y));
}

//------ main.js ------
import { square, diag } from 'lib';
console.log(square(11)); // 121
console.log(diag(4, 3)); // 5
```

`import`指令可以将模块引入到当前命名空间内，与`require`和`define`相比而言，`import`不是动态的，它不能作为函数在任意地方被调用，它只是一个语法上的指令。`export`指令则可以制定哪些值或函数可以导出。

`import`和`export`的静态特性能够使代码在执行前的静态编译阶段就能构建真个应用的依赖关系树。不过实际上，ES2015 只是规定了静态加载模块这个方案的指令语法，它自己只会在静态阶段识别这些指令但具体的加载操作并不负责，这些操作需要由各浏览器厂商实现。当前大部分主流的浏览器，比如 Chrome，Firefox 和 Safari 已经实现了 ES2015 的加载操作。

在浏览器中使用 ES2015 模块：

```javascript
// html.js
export function tag(tag, text) {
    const el = document.createElement(tag);
    el.textContent = text;

    return el;
}
```

```html
<script type="module">
    import { tag } from './html.js';

    const h1 = tag('h1', '👋 Hello Modules!');
    document.body.appendChild(h1);
</script>
```

只要在`script`标签添加`type="module"`，不管该 `script` 是外部引用还是内嵌的形式，都会被浏览器当作模块进行处理。浏览器会将模块与`import`的路径相对应，同一个模块只会被下载和执行一次。

### 优势

-   语法简明
-   支持静态编译
-   原生解决方案(意味着最终会不需要以来任何库进行使用)
-   支持循环依赖

### 缺点

-   原生支持性差一些(考虑到兼容绝大多数浏览器，目前大部分项目还是采用的 Babel 对 ES2015 的模块指令进行了转译)

## 总结

模块创建和依赖管理曾是长时间困扰 js 开发者的难题，现在随着三方库的解决方案和 ES2015 原生模块的出现，这些难题基本上已经被处理掉大部分。如果你正着手开始一个新项目，那么使用 ES2015 模块会是一个不错的选择，因为它属于原生规范会被永久性支持，即使在当前真实的开发环境下需要使用 Babel 进行转译，但你只需要简单的配置一下就能换取开发中无时无刻的便利。当然，如果你偏好于 ES5 或者属于比较老的项目，那么常规的服务端 CommonJs/Node 和客户端 AMD 也仍然是一个比较靠谱的方案。
